<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Paxos算法分析]]></title>
      <url>/2018/04/12/Paxos%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Paxos算法是基于消息传递且具有高度容错特性的一致性算法。</p>
<p>在常见的分布式系统中，总会发生诸如机器宕机或网络异常（包括消息的延迟、丢失、重复、乱序，还有网络分区）等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p>
<a id="more"></a>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>在Paxos算法中，有三种角色：</p>
<p>Proposer（提出提案者）</p>
<p>Acceptor（提案接收者）</p>
<p>Learners（提案学习者）</p>
<p>在具体的实现中，一个进程可能同时充当多重角色，比如一个进程可能既是Proposer又是Acceptor又是Learner</p>
<p>还有个概念是提案Proposal。最终要达成一致的value就在提案里。</p>
<h2 id="最终目的"><a href="#最终目的" class="headerlink" title="最终目的"></a>最终目的</h2><p>希望达到所有acceptor接受的提案的value值是一致的</p>
<h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><h5 id="阶段1"><a href="#阶段1" class="headerlink" title="阶段1"></a>阶段1</h5><p>acceptor接受它接收到的第一个proposal，并选定proposal中的value。</p>
<p>但是：</p>
<p>如果每个acceptor只接收一个proposal，那么多个proposer提出的多个proposal就可能分别被不同的acceptor接收并选定，这样的话就会出现不一致。</p>
<h5 id="阶段2"><a href="#阶段2" class="headerlink" title="阶段2"></a>阶段2</h5><p>acceptor可以接收多个proposal，这样一个proposal就由方案编号和value组成，一个方案选定必须有超过半数的acceptor接受。</p>
<p>但是：</p>
<p>如果有5个acceptor，其中一个宕机，proposer2提出一个proposal[M1,V1]，并被超过半数acceptor接受，此时宕机的acceptor1恢复，且此时proposal2向其发送了一个proposal[M2，V2] (M2&gt;M1,V2!=V1)，因为此acceptor此前没接收过proposal，所以它会接受该proposal，这样就会又不一致了。</p>
<h5 id="阶段3"><a href="#阶段3" class="headerlink" title="阶段3"></a>阶段3</h5><p>被acceptor选定的提案都具有相同的value值。即：如果某个value为v的提案被选定了，那么每个编号更高的被选定的提案的value必须也是v，这就引出了Proposal的生成，对于任意的M和V,如果提案[M，V]被提出，那么存在一个半数以上的Acceptor组成的集合S,满足以下两个条件中的任意一个：</p>
<p>S中每个Acceptor都没有接受过编号小于N的提案。</p>
<p>S中Acceptor接受过的最大编号的提案的value为V。</p>
<p>为满足以上要求，在proposer提出方案之前，要去learn每个acceptor选定的value，然后决定自己的value值。</p>
<p>提案生成算法：</p>
<p>proposer选择一个新的提案编号M,然后向某个acceptor集合（半数以上）发送请求，要求该集合中的每个acceptor做出如下响应：</p>
<p>（a）向proposer承诺保证不接收任何编号小于M的提案</p>
<p>（b）如果Acceptor已经接受过提案，那么就向Proposer响应已经接受过得编号小于M的最大编号的提案。</p>
<p>如果proposer收到超过半数的acceptor的响应，那么它就可以生成编号为M,value为V的提案[M，V]。这里的V是所有响应的acceptor中编号最大的提案的value。如果所有响应中没有提案，则V就由proposer自己选择。</p>
<p>生成提案后，proposer将该提案发送给半数以上的Acceptor集合，并期望这些Acceptor能接受该提案。</p>
<p>但是：</p>
<p>如果有两个proposer,p1发出提案[M1,V1]，learn的结果是收到半数acceptor响应，acceptor承诺不接收小于M1的提案。此时p2提出提案[M2，V2],learn的结果是收到半数acceptor响应并承诺不接收小于M2的提案（M2&gt;M1），接着p1因为收到半数acceptor的响应，故将提案提出，但是因为acceptor后来接受过M2，所以会忽略p1的提案，此时p1又会生成提案M3(M3&gt;M2)，这样p2的提案又会被忽略，如此循环，就会没有提案被接受</p>
<h5 id="阶段4"><a href="#阶段4" class="headerlink" title="阶段4"></a>阶段4</h5><p>通过选取一个主proposer，只有主proposer才能提出提案。那其实在主proposer任职期间也就不需要learn了。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法，分布式，Paxos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL事务之隔离级别详解]]></title>
      <url>/2018/03/21/MySQL%E4%BA%8B%E5%8A%A1%E4%B9%8B%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><p>1.原子性</p>
<p>事务必须是原子工作单元。对于数据修改，要么全都执行，要么全都不执行。</p>
<p>2.一致性</p>
<p>事务在完成时，必须使所有的数据都保持一致状态。（理解：事务开始和结束之间的中间状态不会被其他事务看到，举例：同一家银行内转账，A转给B 1000元，则A和B的总值是不变的，A减去1000，B加上1000的中间状态，外部是无感知的）</p>
<a id="more"></a>
<p>3.隔离性</p>
<p>由并发事务所作的修改必须与任何其他并发事务所作的修改隔离。</p>
<p>4.持久性</p>
<p>事务完成之后，它对于系统的影响是永久性的。</p>
<h2 id="数据库针对事务的四种隔离级别"><a href="#数据库针对事务的四种隔离级别" class="headerlink" title="数据库针对事务的四种隔离级别"></a>数据库针对事务的四种隔离级别</h2><p>脏读：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，如果前一个rollBack了，则后一个事务所读取的数据就会是不正确的。</p>
<p>不可重复读：在一个事务的两次查询之中数据不一致，可能是两次查询过程中插入了一个事务更新的原有的数据。</p>
<p>幻读：在一个事务的两次查询中数据数不一致。例如有一个事务查询了几列数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
<p>1.Read Uncommitted(读取未提交内容)</p>
<p>在该隔离级别，所有事务都可以看见其他未提交事务的执行结果。这种隔离级别可能导致脏读，不可重复读和幻读。</p>
<p>2.Read Committed(读取提交内容)</p>
<p>这是大多数数据库的默认隔离级别（MySQL不是），它满足了隔离的简单定义：一个事务只能看见自己已经提交的事务所做的改变，这种情况也会导致不可重复读，因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一个select可能会有不同的结果。</p>
<p>3.Repeatable Read(可重读)</p>
<p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致新的问题：幻读，据说InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。但是似乎并没有彻底解决这个问题：参见博客<a href="http://blog.csdn.net/cweeyii/article/details/70991230" target="_blank" rel="noopener">http://blog.csdn.net/cweeyii/article/details/70991230</a></p>
<p>4.Serializable(可串行化)</p>
<p>这是最高隔离级别，它通过强制事务排序，使之不可能冲突，从而解决幻读问题。简言之，它是在每个读的行上加上共享锁。这个级别，可能导致大量的超时现象和锁竞争。</p>
<h2 id="数据库的各种锁"><a href="#数据库的各种锁" class="headerlink" title="数据库的各种锁"></a>数据库的各种锁</h2><p>InnoDB支持事务，支持行锁和表锁，Myisam不支持事务，只支持表锁</p>
<p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁</p>
<p>排它锁（X）：允许获得排它锁的事务更新数据，阻止其他事务获得相同数据集的共享读锁和排他写锁</p>
<p>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁</p>
<p>意向排它锁（IX）：事务打算给数据行加行排它锁，事务在给一个数据行加排它锁前必须先取得该表的IX锁</p>
<p>说明：</p>
<p>1）共享锁和排它锁都是行锁，意向锁都是表锁，应用中我们只会使用共享锁和排它锁，意向锁是mysql内部使用的，不需要用户干预。</p>
<p>2）对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排它锁（X）,对于普通SELECT语句，InnoDB不会加任何锁，事务可以通过以下语句显示给记录集加共享锁或排它锁。</p>
<p>共享锁（S）:SELECT * FROM table_name WHERE … LOCK IN SHARE MODE</p>
<p>排它锁（X）:SELECT * FROM table_name WHERE … FOR UPDATE</p>
<p><strong>对于锁定行记录后需要进行更新操作的应用，应该使用Select…for Update方式，获取排它锁。</strong></p>
<p><strong>如果用共享锁，在读了之后再写会阻塞，可能会导致死锁，举例：</strong></p>
<p>session 1：set autocommit = 0 (开启事务); select * from test where id = 1 lock in share mode;</p>
<p>session 2：set autocommit = 0;select * from test where id = 1 lock in share mode;</p>
<p>这个时候两个session同时持有id = 1这行数据的共享锁。这个时候我们再执行：</p>
<p>session 1：update test set coll = ‘AAA’ where id = 1;</p>
<p>这个时候session 1必须等待session 2退出事务或者等待直到锁超时</p>
<p>如果我们在session 2里面执行：</p>
<p>session 2: update test set coll = ‘BBB’ where id = 1;</p>
<p>ERROR 1213 (40001) ：Deadlock found when trying to get lock;try restarting</p>
<p>这个时候mySQL会检测到发生死锁，会中断当前事务该语句的执行，重新开启一个新的事务</p>
<p><strong>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（Update、DELETE、INSERT等）前，会自动给涉及的表加写锁</strong></p>
<p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才能使用行级锁，否则，InnoDB将使用表锁！</strong></p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 事务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL索引之Index Condition Pushdown]]></title>
      <url>/2018/03/21/MySQL%E7%B4%A2%E5%BC%95%E4%B9%8BIndex-Condition-Pushdown/</url>
      <content type="html"><![CDATA[<h2 id="导入示例数据"><a href="#导入示例数据" class="headerlink" title="导入示例数据"></a>导入示例数据</h2><p>与之前的MySQL文章一样，使用Employees Sample Database，作为示例数据库。</p>
<p>employees表包含的基本信息，表结构如下： <img src="/2018/03/21/MySQL索引之Index-Condition-Pushdown/屏幕快照 2018-03-21 下午2.24.25.png" alt="屏幕快照 2018-03-21 下午2.24.25"></p>
<a id="more"></a>
<p>这个表默认只有一个主索引，因为ICP只能作用于二级索引，故建一个二级索引： <img src="/2018/03/21/MySQL索引之Index-Condition-Pushdown/屏幕快照 2018-03-21 下午2.26.04.png" alt="屏幕快照 2018-03-21 下午2.26.04"></p>
<p>这样就建立了一个first_name和last_name的联合索引。</p>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>为了明确看到查询的性能，我们启动profiling并关闭query cache: <img src="/2018/03/21/MySQL索引之Index-Condition-Pushdown/屏幕快照 2018-03-21 下午2.28.08.png" alt="屏幕快照 2018-03-21 下午2.28.08"></p>
<p>然后看下面的查询： <img src="/2018/03/21/MySQL索引之Index-Condition-Pushdown/屏幕快照 2018-03-21 下午2.29.13.png" alt="屏幕快照 2018-03-21 下午2.29.13"></p>
<p>根据MySQL索引的前缀匹配原则，两者对索引的使用是一致的，即只有first_name采用索引，last_name由于使用了模糊前缀，没法使用索引进行匹配。我将查询联系执行三次，结果如下： <img src="/2018/03/21/MySQL索引之Index-Condition-Pushdown/屏幕快照 2018-03-21 下午2.32.13.png" alt="屏幕快照 2018-03-21 下午2.32.13"></p>
<p>然后我们关闭ICP: <img src="/2018/03/21/MySQL索引之Index-Condition-Pushdown/屏幕快照 2018-03-21 下午2.33.00.png" alt="屏幕快照 2018-03-21 下午2.33.00"></p>
<p>在运行三次相同的查询，结果如下：</p>
<p><img src="/Users/liukaizhao/截图/屏幕快照 2018-03-21 下午2.33.56.png" alt="屏幕快照 2018-03-21 下午2.33.56"></p>
<p>耗时信息如下： <img src="/2018/03/21/MySQL索引之Index-Condition-Pushdown/屏幕快照 2018-03-21 下午2.34.43.png" alt="屏幕快照 2018-03-21 下午2.34.43"></p>
<p>前者是开启ICP，后者是关闭ICP。可以看到区别在于Extra，开启ICP时，用的是Using index condition；关闭ICP时，是Using where。其中Using index condition 就是ICP提高查询性能的关键。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ICP的原理简单来说就是将可以利用索引筛选的where条件在存储引擎一侧进行筛选，而不是将所有index access的结果取出来放在server端进行where筛选。</p>
<p>以上面查询为例，在没有ICP时，首先通过索引前缀从存储引擎中读出224条first_name为Mary的记录，然后在server段用where筛选last_name的like条件；启用ICP后，由于last_name的like筛选可以通过索引字段进行，那么存储引擎内部通过索引与where条件的对比来筛选掉不符合where条件的记录，这个过程不需要读出整条记录，同时只返回给server筛选后的6条记录，因此提高了查询性能。 <img src="/2018/03/21/MySQL索引之Index-Condition-Pushdown/屏幕快照 2018-03-21 下午2.53.58.png" alt="屏幕快照 2018-03-21 下午2.53.58"> <img src="/2018/03/21/MySQL索引之Index-Condition-Pushdown/屏幕快照 2018-03-21 下午3.30.16.png" alt="屏幕快照 2018-03-21 下午3.30.16"></p>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>有几个关于ICP的事情要注意：</p>
<ul>
<li>ICP只能用于二级索引，不能用于主索引。</li>
<li>也不是全部where条件都可以用ICP筛选，如果某where条件的字段不在索引中，当然还是要读取整条记录做筛选，在这种情况下，仍然要到server端做where筛选。</li>
<li>ICP的加速效果取决于在存储引擎内通过ICP筛选掉的数据的比例。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL索引之使用策略及优化]]></title>
      <url>/2018/03/16/MySQL%E7%B4%A2%E5%BC%95%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="优化分类及示例数据库"><a href="#优化分类及示例数据库" class="headerlink" title="优化分类及示例数据库"></a>优化分类及示例数据库</h2><p>参考文章地址：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>
<p>MySQL的优化只要分为结构优化和查询优化。</p>
<h4 id="示例数据库"><a href="#示例数据库" class="headerlink" title="示例数据库"></a>示例数据库</h4><p>为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选择MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图：</p>
<a id="more"></a>
<p><img src="/2018/03/16/MySQL索引之使用策略及优化/12.png" alt="12"></p>
<p>MySQL官方文档中关于此数据库的页面为<a href="http://dev.mysql.com/doc/employee/en/employee.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/employee/en/employee.html</a>，里面详细介绍了此数据库，并提供了下载地址和导入方法。</p>
<h4 id="最左前缀原理与相关优化"><a href="#最左前缀原理与相关优化" class="headerlink" title="最左前缀原理与相关优化"></a>最左前缀原理与相关优化</h4><p>高效使用索引的首要条件是知道什么样的查询会使用索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。</p>
<p>这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定的顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组<a1,a2,....an>,其中各个元素均为数据表的一列，实际上要严格定义索引需要用到的关系代数，但是这里不讨论太多关系代数的话题，单列索引可以看成联合索引元素数为1的特例。</a1,a2,....an></p>
<p>以employees.titles表为例，下面先查看其上都有哪些索引：</p>
<p><img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午4.36.45.png" alt="屏幕快照 2018-03-16 下午4.36.45"></p>
<p>从结果中可以看到titles表的主索引为<emp_no,title,from_date>,还有一个辅助索引<emp_no>。为了避免多个索引使事情变得复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将附注索引drop掉，专心分析索引PRIMARY的行为。</emp_no></emp_no,title,from_date></p>
<h5 id="情况一：全列匹配"><a href="#情况一：全列匹配" class="headerlink" title="情况一：全列匹配"></a>情况一：全列匹配</h5><p><img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午4.41.02.png" alt="屏幕快照 2018-03-16 下午4.41.02"></p>
<p>很明显，当按照索引中所有列进行精确匹配时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：</p>
<p><img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午4.44.00.png" alt="屏幕快照 2018-03-16 下午4.44.00"></p>
<p>效果是一样的。</p>
<h5 id="情况二：最左前缀匹配"><a href="#情况二：最左前缀匹配" class="headerlink" title="情况二：最左前缀匹配"></a>情况二：最左前缀匹配</h5><p><img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午4.45.01.png" alt="屏幕快照 2018-03-16 下午4.45.01"></p>
<p>当查询条件精确匹配索引的左边连续一个或几个列时，如<emp_no>或<emp_no,titile>，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果中看到用了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。</emp_no,titile></emp_no></p>
<h5 id="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"><a href="#情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。" class="headerlink" title="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"></a>情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。</h5><p><img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午4.49.39.png" alt="屏幕快照 2018-03-16 下午4.49.39"></p>
<p>此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引<emp_no,from_date>，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。</emp_no,from_date></p>
<p>首先我们看一下title一共有几种不同的值： <img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午4.55.35.png" alt="屏幕快照 2018-03-16 下午4.55.35"></p>
<p>只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用IN来填补这个“坑”从而形成最左前缀：</p>
<p><img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午4.57.23.png" alt="屏幕快照 2018-03-16 下午4.57.23"></p>
<p>这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：</p>
<p><img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午5.03.27.png" alt="屏幕快照 2018-03-16 下午5.03.27"></p>
<p>“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然title的值很多，用填坑就不合适了，必须建立辅助索引。</p>
<h5 id="情况四：查询条件没有指定索引第一列"><a href="#情况四：查询条件没有指定索引第一列" class="headerlink" title="情况四：查询条件没有指定索引第一列 "></a>情况四：查询条件没有指定索引第一列 <img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午5.06.48.png" alt="屏幕快照 2018-03-16 下午5.06.48"></h5><p>由于不是最左前缀，索引这样的查询显然用不到索引</p>
<h5 id="情况五：匹配某列的前缀字符串"><a href="#情况五：匹配某列的前缀字符串" class="headerlink" title="情况五：匹配某列的前缀字符串 "></a>情况五：匹配某列的前缀字符串 <img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午5.08.31.png" alt="屏幕快照 2018-03-16 下午5.08.31"></h5><p>此时可以用到索引，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀。</p>
<h5 id="情况六：范围查询"><a href="#情况六：范围查询" class="headerlink" title="情况六：范围查询 "></a>情况六：范围查询 <img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午5.10.45.png" alt="屏幕快照 2018-03-16 下午5.10.45"></h5><p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。 <img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午5.27.51.png" alt="屏幕快照 2018-03-16 下午5.27.51"></p>
<p>可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：</p>
<p><img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午5.31.07.png" alt="屏幕快照 2018-03-16 下午5.31.07"></p>
<p>看起来是用来两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。</p>
<h5 id="情况七：查询条件中含有函数或表达式"><a href="#情况七：查询条件中含有函数或表达式" class="headerlink" title="情况七：查询条件中含有函数或表达式"></a>情况七：查询条件中含有函数或表达式</h5><p>很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引。例如： <img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午5.37.21.png" alt="屏幕快照 2018-03-16 下午5.37.21"></p>
<p>虽然这个查询和情况五中功能相同，但是由于使用了函数left,则无法为title列应用索引，而情况五中用Like则可以。再如： <img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午5.52.49.png" alt="屏幕快照 2018-03-16 下午5.52.49"></p>
<p>显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手动代数运算，转换为无表达式的查询语句。</p>
<h4 id="索引选择性与前缀索引"><a href="#索引选择性与前缀索引" class="headerlink" title="索引选择性与前缀索引"></a>索引选择性与前缀索引</h4><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p>
<p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p>
<p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p>
<p>Index Selectivity = Cardinality / #T</p>
<p>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性： <img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午5.57.21.png" alt="屏幕快照 2018-03-16 下午5.57.21"></p>
<p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p>
<p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。</p>
<p>从图中可以看到employees表只有一个索引<emp_no>，那么如果我们想按名字搜索一个人，就只能全表扫描了： <img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午5.57.58.png" alt="屏幕快照 2018-03-16 下午5.57.58"></emp_no></p>
<p>如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<first_name>或<first_name, last_name="">，看下两个索引的选择性： <img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午5.59.03.png" alt="屏幕快照 2018-03-16 下午5.59.03"></first_name,></first_name></p>
<p><first_name>显然选择性太低，<first_name, last_name="">选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如<first_name, left(last_name,="" 3)="">，看看其选择性：</first_name,></first_name,></first_name></p>
<p><img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午5.59.37.png" alt="屏幕快照 2018-03-16 下午5.59.37"></p>
<p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4： <img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午6.00.15.png" alt="屏幕快照 2018-03-16 下午6.00.15"></p>
<p>这时选择性已经很理想了，而这个索引的长度只有18，比<first_name, last_name="">短了接近一半，我们把这个前缀索引 建上：</first_name,></p>
<p><img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午6.01.01.png" alt="屏幕快照 2018-03-16 下午6.01.01"></p>
<p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</p>
<p><img src="/2018/03/16/MySQL索引之使用策略及优化/屏幕快照 2018-03-16 下午6.01.33.png" alt="屏幕快照 2018-03-16 下午6.01.33"></p>
<p>性能的提升是显著的，查询速度提高了120多倍。</p>
<p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p>
<h4 id="InnoDB的主键选择与插入优化"><a href="#InnoDB的主键选择与插入优化" class="headerlink" title="InnoDB的主键选择与插入优化"></a>InnoDB的主键选择与插入优化</h4><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p>
<p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p>
<p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p>
<p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示： <img src="/2018/03/16/MySQL索引之使用策略及优化/13.png" alt="13"></p>
<p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p>
<p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置： <img src="/2018/03/16/MySQL索引之使用策略及优化/14.png" alt="14"></p>
<p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
<p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL索引之MyISAM和InnoDB存储引擎]]></title>
      <url>/2018/03/16/MySQL%E7%B4%A2%E5%BC%95%E4%B9%8BMyISAM%E5%92%8CInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      <content type="html"><![CDATA[<h2 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h2><p>MyISAM引擎使用B+Tree作为索引结构，叶子结点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p>
<p> <img src="/2018/03/16/MySQL索引之MyISAM和InnoDB存储引擎/8.png" alt="8"></p>
<a id="more"></a>
<p>这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p> <img src="/2018/03/16/MySQL索引之MyISAM和InnoDB存储引擎/9.png" alt="9"></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h2 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h2><p>InnoDB使用B+Tree作为索引结构，但具体实现方式与MyISAM截然不同</p>
<p>最大区别在于InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。 <img src="/2018/03/16/MySQL索引之MyISAM和InnoDB存储引擎/10.png" alt="10"></p>
<p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶子结点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按照主键聚集，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p>
<p> <img src="/2018/03/16/MySQL索引之MyISAM和InnoDB存储引擎/11.png" alt="11"></p>
<p>这里是以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按住键的搜索十分高效，但是辅助索引需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。根据InnoDB的实现原理，我们可以明白当使用该索引时，不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大；再比如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新纪录时数据文件为了维持B+Tree的特性儿频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<p>参考文章地址：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>
]]></content>
      
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL索引之数据结构及应用原理]]></title>
      <url>/2018/03/16/MySQL%E7%B4%A2%E5%BC%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BA%94%E7%94%A8%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>参考文章地址：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>
<p>目前大部分数据库系统及文件系统都采用B-tree或其变种B+tree作为索引结构。</p>
<p>B-tree和B+tree之前的博客已经分析过了，这里不再复述。</p>
<h4 id="采用B-Tree-B-Tree-的原因"><a href="#采用B-Tree-B-Tree-的原因" class="headerlink" title="采用B-Tree(B+Tree)的原因"></a>采用B-Tree(B+Tree)的原因</h4><p>一般来说，索引本身也很大，不可能全部存储于内存中，因此索引往往以索引文件</p>
<a id="more"></a>
<p>的形式存储于磁盘上。这样的话，索引查找过程中就要产生磁盘I/O的消耗，相对于内存存取，I/O存取的消耗要高于几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中I/O的存取次数。下面先说明一下内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p>
<h5 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h5><p>目前计算机使用的主存基本上都是随机读写存储器（RAM）,现代RAM的结构和存取原理比较复杂，这里抽象一个十分简单的存取模型来说明RAM的工作原理</p>
<p> <img src="/2018/03/16/MySQL索引之数据结构及应用原理/5.png" alt="5"></p>
<p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个数据单元有唯一的地址，现代主存的遍址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定为到一个存储单元。上图展示了一个4*4的主存模型</p>
<p>主存的存取过程如下：</p>
<p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其他部件读取。</p>
<p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p>
<p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p>
<h5 id="磁盘存储原理"><a href="#磁盘存储原理" class="headerlink" title="磁盘存储原理"></a>磁盘存储原理</h5><p>索引一般是以文件的形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p>
<p>磁盘示意图如下：</p>
<p> <img src="/2018/03/16/MySQL索引之数据结构及应用原理/6.png" alt="6"></p>
<p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁盘任何时候都是重叠的（目前已经有多个磁头独立技术）</p>
<p>下图是磁盘结构的示意图：</p>
<p> <img src="/2018/03/16/MySQL索引之数据结构及应用原理/7.png" alt="7"></p>
<p>盘片被分化为一系列同心环，圆心是盘片的中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分为一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。</p>
<p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p>
<h5 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h5><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p>
<p>当一个数据被用到时，其附件的数据也通常被马上用到。</p>
<p>程序运行期间所需要的数据通常比较集中。</p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需要很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往会将主存和磁盘存储区分割为连续的大小相等的块，每个存储块为一页（许多操作系统中，页得大小通常为4k）,主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h5 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h5><p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个结点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个结点的大小设为等于一页，这个每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建结点时，直接申请一个页的空间，这样就保证了一个结点物理也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（注意：根节点常驻内存），渐进复杂度为O(h) = O(log_dN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的结点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<p>上文还说过，B+Tree更适合外存索引，原因和内结点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p>
<p>d(max) = floor( pagesize / (keysize + datasize + pointsize) )</p>
<p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[B+树数据结构]]></title>
      <url>/2018/03/15/B+%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>B+树是应文件系统所需而出的一种B树的变形树。一棵m阶的B+树和m阶的B树的差异在于：</p>
<p>1.如果此B+树的序数（度数）为d,则除了根之外的每个结点都包含最少d/2个元素最多d-1个元素，对于任意的结点有最多d个子指针。对于所有内部结点，子指针的数目总是比元素的数目多一个。（每个内部结点的元素充当分开它的子树的分离值。</p>
<a id="more"></a>
<p>例如，如果内部结点有三个子节点（或子树）则它必须有两个分离值或元素a1和a2。在最左子树中所有的值都小于等于a1,在中间子树中所有的值都在a1和a2之间（a1,a2],而在最右子树中所有的值都大于a2。注意：这里最左子树的值可以是小于a1,中间为[a1,a2)，右边为大于等于a2）</p>
<p>2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点内部依关键字的大小自小而大顺序链接。</p>
<p>3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。</p>
<p>通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</p>
<p>由于并不是所有结点都具有相同的域，因此B+树中叶子结点和内结点一般大小不同。这点与B-tree不同，虽然B-Tree中不同结点存放的key和指针可能数量不一致，但是每个结点的域和上限是一致的，所以在实现中B-tree往往对每个结点申请同等大小的空间。</p>
<h2 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h2><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>1.以下图为例，此B+树</p>
<p> <img src="/2018/03/15/B+树数据结构/990532-20170117134342692-774752969.png" alt="990532-20170117134342692-774752969"></p>
<p>2.插入28这个值，由于Leaf Page和Index Page都没满，所以直接插入就可以</p>
<p> <img src="/2018/03/15/B+树数据结构/990532-20170117134602864-1401463251.png" alt="990532-20170117134602864-1401463251"></p>
<p>3.插入70这个值，这时原先的Leaf Page已经满了，但是Index Page还没有满，此时拆分Leaf Page，将中间节点放入Index Page中，小于中间节点的记录放左边，大于等于中间节点的记录放右边</p>
<p> <img src="/2018/03/15/B+树数据结构/990532-20170117134652286-620013872.png" alt="990532-20170117134652286-620013872"></p>
<p>4.再插入95这个值，这时Leaf Page和Index Page都满了，此时需要拆分Leaf Page，小于中间节点的记录放左边，大于等于中间节点的记录放右边，拆分Index page，小于中间节点的记录放左边，大于中间节点的记录放右边，中间节点放入上一层Index Page</p>
<p> <img src="/2018/03/15/B+树数据结构/990532-20170117134820692-680638285.png" alt="990532-20170117134820692-680638285"></p>
<p>可以看到，不管怎么变化，B+树总是会保持平衡。但是为了保持平衡，对于新插入的键值可能需要做大量的拆分页操作，而B+树主要用于磁盘，因此页的拆分意味着磁盘的操作，应该尽可能的减少页的拆分。因此，B+树提供了旋转的功能。</p>
<p>旋转发生在Leaf Page已经满了，但是其左右兄弟结点没有满的情况下。这时B+树并不急于去做拆分页的操作，而是将记录移到所在页的兄弟结点上。通常情况下，左兄弟被首先检查用来做旋转操作，这时我们插入键值70，其实B+树并不会急于去拆分叶结点，而是做旋转，如下图：（50，55，55旋转） <img src="/2018/03/15/B+树数据结构/990532-20170117135001442-1547516540.png" alt="990532-20170117135001442-1547516540"></p>
<p>可以看出，采用旋转操作使B+树减少了一次页的拆分操作，且这时B+树的高度依然是2。</p>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>B+树使用填充因子（fill factor）来控制树的变化，50%是填充因子可设的最小值。B+树的删除操作同样必须保证删除后叶子节点的记录依然排序</p>
<p>1.以下图为例：</p>
<p><img src="/2018/03/15/B+树数据结构/屏幕快照 2018-03-15 下午6.07.37.png" alt="屏幕快照 2018-03-15 下午6.07.37"></p>
<p>2.删除键值为70这条记录</p>
<p> <img src="/2018/03/15/B+树数据结构/屏幕快照 2018-03-15 下午6.13.16.png" alt="屏幕快照 2018-03-15 下午6.13.16"></p>
<p>3.删除键值为25的记录，虽然包含25的叶子大于fill factor，但是不同的是该值还在Index Page中的值，因此再删除Leaf Page中的25的值后，还应将25的右兄弟结点的28更新到Page Index中</p>
<p><img src="/2018/03/15/B+树数据结构/屏幕快照 2018-03-15 下午6.17.31.png" alt="屏幕快照 2018-03-15 下午6.17.31"></p>
<p>4.删除键值为60的记录，因为Leaf Page删除60之后，填充因子小于50%,这是需要做合并操作，同样，再删除Index Page中相关记录后需要做Index Page的合并操作</p>
<p> <img src="/2018/03/15/B+树数据结构/屏幕快照 2018-03-15 下午7.09.17.png" alt="屏幕快照 2018-03-15 下午7.09.17"></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Tree </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[B-Tree数据结构]]></title>
      <url>/2018/03/14/B-Tree%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>B-tree即为B树，B即为Balanced</p>
<p>B-tree是一种多路搜索树（不一定是二叉的）</p>
<p>一颗m阶B树是一颗平衡的m路搜索树（m阶是指B树中每个结点至多具有M棵子树，m阶B树又可称为m/2度B树，度和阶是分别描述树的方式）。它或者是空树，或者是满足下列性质的树：</p>
<p>1.根结点至少有两个子女</p>
<a id="more"></a>
<p>2.每个非根结点所包含的关键字个数j满足：m/2-1 &lt;=j&lt;= m-1;</p>
<p>3.除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数k满足：m/2 &lt;=k&lt;= m;</p>
<p>4.所有的叶子结点都位于同一层</p>
<p>在B树中，每个结点中关键字从小到大排列，并且当该结点的孩子是非叶子结点时，该k-1个关键字正好是k个孩子包含的关键字的值域的分划。</p>
<p>因为叶子结点不包含关键字，所以可以把叶子结点看成在树里实际上并不存在外部结点，指向这些外部结点的指针为空，叶子结点的数目正好等于树中所包含的关键字总个数加1。</p>
<h2 id="2-B-tree的插入和删除"><a href="#2-B-tree的插入和删除" class="headerlink" title="2.B-tree的插入和删除"></a>2.B-tree的插入和删除</h2><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>插入一个元素时，首先在B树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素，注意：如果叶子结点空间足够，即小于阶数m，这里需要向右移动该叶子结点中大于新插入关键字的元素，如果空间满了以致没有足够的空间去添加新的元素，则将该结点进行分裂，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中（如果父结点空间也满了，也同样需要分裂操作），而且当结点中关键字元素向右移动了，相关的指针也需要向右移。如果在根结点插入新元素，空间满了，则进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。</p>
<p>示例：</p>
<p>一个4阶的B-tree（非根结点关键字数小于2个就合并，大于4个就分裂）</p>
<p>1.先有4个字母</p>
<p> <img src="/2018/03/14/B-Tree数据结构/20150906171641792.jpg" alt="20150906171641792"></p>
<p>2.当插入H时，发现空间不够，以致将其分裂成2个结点，移动中间元素G上移到新的根结点中，在实现过程中，咱们把A和C留在当前结点中，而H和N放置新的其右邻居结点中。</p>
<p> <img src="/2018/03/14/B-Tree数据结构/20150906171720873.jpg" alt="20150906171720873"></p>
<p>3.当插入E,K,Q时，不需要任何分裂操作</p>
<p> <img src="/2018/03/14/B-Tree数据结构/20150906171806173.jpg" alt="20150906171806173"></p>
<p>4.插入M需要一次分裂，注意M恰好是中间关键字元素，以致向上移到父节点中。如图：</p>
<p> <img src="/2018/03/14/B-Tree数据结构/20150906171910766.jpg" alt="20150906171910766"></p>
<p>5.插入F,W,L,T不需要任何操作。如图：</p>
<p> <img src="/2018/03/14/B-Tree数据结构/20150906171944726.jpg" alt="20150906171944726"></p>
<p>6.插入Z时，最右的叶子结点空间满了，需要进行分裂操作，中间元素T上移到父节点中，注意上移中间元素，树最终还是保持平衡，分裂结果的结点存在2个关键字元素 <img src="/2018/03/14/B-Tree数据结构/20150906172007317.jpg" alt="20150906172007317"></p>
<p>7.插入D时，导致最左边的叶子结点被分裂，D恰好也是中间元素，上移到父节点中，然后字母P,R,X,Y陆续插入不需要任何分裂操作。如图：</p>
<p> <img src="/2018/03/14/B-Tree数据结构/20150906172038313.jpg" alt="20150906172038313"></p>
<p>8.最后插入S时，含有N,P,Q,R的结点需要分裂，把中间元素Q上移到父节点中，但是父节点空间也满了，所以也要分裂，将父节点中的中间元素M上移到新形成的根结点中，注意以前在父节点中第三个指针在修改后包括D和G节点中，这样具体插入操作完成 <img src="/2018/03/14/B-Tree数据结构/20150906172114106.jpg" alt="20150906172114106"></p>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>若被删关键字K所在的结点非树叶，则用K的中序前趋（或后继）K’取代K,然后从叶子中删去K’。（前趋结点：结点val值小于该结点val值并且值最大的结点；后继结点：节点val值大于该结点val值并且最小的结点）</p>
<p>从叶子开始删去某关键字K的三种情形为：</p>
<p>1.若x-&gt;keyNum&gt;min,则只需删去K及其右指针（x如果是叶子，则右指针为空），即可使删除操作结束</p>
<p>2.若x-&gt;keyNum=min,该叶子中的关键字个数已是最小值，删除K及其右指针后会破坏B树的特性（除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加一，故内部子树k满足：m/2 &lt;= k &lt;= m）。若x的左（或右）邻兄弟结点y中的关键字数目大于Min,则将y中的最大（或最小）关键字上移至双亲结点parent中，而将parent中相应的关键字下移至x中。显然这种移动使得双亲中关键字数目不变；y被移出一个关键字，故其keyNum减一，因它原大于Min，故减少1个关键字后keyNum仍大于等于Min;而x中已移入一个关键字，故删K后x中仍有Min个关键字。）</p>
<p>3.若x及其相邻的左右兄弟中的关键字数目均为最小值Min，则上述的移动操作就不奏效，此时须x和左或者右兄弟合并。不妨设x有右邻兄弟y(对左类似)，在x中删去K后，将双亲结点parent中介于x和y之间的关键字K,作为中间关键字，并与x和y中的关键字一起合并为一个新的结点取代x和y。因为x和y原各有Min个关键字，从双亲中移入的K’抵消了从x中删除的K,故新节点中恰好有2Min个关键字，没有破坏B-tree的上述性质（3）。但由于K’从双亲中移动到新节点后，相当于从parent中删去了K’,若parent-&gt;keyNum原大于Min,则删除操作到此结束；否则，同样要通过移动parent的左右兄弟中的关键字或将parent与其左右兄弟合并的方法来维护B-tree性质。最坏情况下，合并操作会上传播至根，当根中只有一个关键字时，合并操作将会使根结点及其两个孩子合并成一个新的根，从而使整棵树的高度减少一层。</p>
<p>以上示例如图：</p>
<p> <img src="/2018/03/14/B-Tree数据结构/20150906172428271.jpg" alt="20150906172428271"></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Tree，数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CAP定理]]></title>
      <url>/2018/02/05/CAP%E5%AE%9A%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>CAP定理，它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<p>一致性：所有节点访问同一份最新的数据副本</p>
<p>可用性：每次请求都能获取到非错的响应,但是不保证获取的数据为最新数据</p>
<a id="more"></a>
<p>分区容错性：已实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择</p>
]]></content>
      
        <categories>
            
            <category> 计算机科学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 分布式，数据一致性 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IO模型解读]]></title>
      <url>/2018/01/08/IO%E6%A8%A1%E5%9E%8B%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h2 id="IO模型分类"><a href="#IO模型分类" class="headerlink" title="IO模型分类"></a>IO模型分类</h2><p>对于一个network IO（以read为例），它会涉及到两个系统对象，一个是调用这个IO的process(or thread)，另一个就是系统内核（kernel）。当一个read操作发生时，它会经历两个阶段：（1）等待数据准备（2）将数据从内核拷贝到进程中</p>
<ol>
<li><p>同步阻塞IO：</p>
<a id="more"></a>
<p>​    在linux中，默认情况下所有socket都是blocking，当用户进程调用read的系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network IO来说，很多时候数据在一开始还没到达（比如，还没收到一个完整的UDP包），这时候kernel就要等待足够的数据到来，而在用户进程这边，整个进程会被阻塞（因为调用没有回应，进程在等待回应）。当kernel一直等待的数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程解除block的状态，继续运行。</p>
<p> <img src="/2018/01/08/IO模型解读/屏幕快照 2018-01-19 下午3.57.18.png" alt="屏幕快照 2018-01-19 下午3.57.18"></p>
</li>
<li><p>同步非阻塞IO:</p>
<p>​    在linux下，可以通过设置socket使其变成non-blocking。当用户进程发起read操作时，如果kernel中的数据还没准备好，那么它并没有block用户进程，而是立刻返回一个error。从用户进程角度来看，它发起了一个read操作，并不需要等待，而是马上就有一个结果。用户进程判断结果是一个error时，它就知道数据还没准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call,那么它马上就将数据拷贝到用户内存，然后返回。所以这种模型下，用户进程其实是需要不断的主动询问kernel数据准备好了没有</p>
<p> <img src="/2018/01/08/IO模型解读/屏幕快照 2018-01-19 下午3.57.30.png" alt="屏幕快照 2018-01-19 下午3.57.30"></p>
</li>
<li><p>IO多路复用：</p>
<p>​    该IO模型是基于select/epoll的。当用户进程调用了select，那么整个进程会被block，而同时kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。这个模型跟blocking IO相比：如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，因为select/epoll是需要使用两个system call( select + read)，而blocking IO只调用一个system call(read)。select/epoll 的优势并不是对于单个连接能处理的更快，而是在于能处理更多的连接。</p>
<p>​    IO多路复用中，每个socket，一般都设置成为non-blocking,但是，用户process还是被阻塞的，只不过是被select函数block的。 <img src="/2018/01/08/IO模型解读/屏幕快照 2018-01-19 下午3.57.39.png" alt="屏幕快照 2018-01-19 下午3.57.39"></p>
<p>​    IO多路复用一般都会和Reactor设计模式配合使用，这样用户process只注册自己感兴趣的socket或者IO请求，然后去做自己的事情，等到数据到来时再进行处理，则可以提高CPU的利用率</p>
<p> <img src="/2018/01/08/IO模型解读/屏幕快照 2018-01-19 下午4.10.11.png" alt="屏幕快照 2018-01-19 下午4.10.11"></p>
</li>
<li><p>异步IO：</p>
<p>用户process发起read操作，即向kernel发送一个asynchronous read之后，会立刻收到内核的返回值。然后kernel等数据准备好，会将数据拷贝到用户内存，当这一切完成后，kernel会给用户进程发送一个signal，告知用户process read操作完成了。</p>
<p>异步IO需要操作系统的支持，且是与Proactor设计模式配合使用的</p>
<p> <img src="/2018/01/08/IO模型解读/屏幕快照 2018-01-19 下午4.20.32.png" alt="屏幕快照 2018-01-19 下午4.20.32"></p>
<p>​</p>
<p>​</p>
<p>参考链接：</p>
<p><a href="http://www.cnblogs.com/fanzhidongyzby/p/4098546.html" target="_blank" rel="noopener">http://www.cnblogs.com/fanzhidongyzby/p/4098546.html</a></p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> IO </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IO </tag>
            
            <tag> 系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[文件描述符]]></title>
      <url>/2018/01/05/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h2 id="描述符解释"><a href="#描述符解释" class="headerlink" title="描述符解释"></a>描述符解释</h2><p>文件描述符（句柄）是内核为了高效管理已被打开的文件所创建的索引，是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。</p>
<p>程序刚刚启动时，0是标准输入，1是标准输出，2是标准错误。</p>
<a id="more"></a>
<p>如果此时去打开一个新的文件，它的文件描述符会是3,POSIX标准要求每次打开文件时（包括socket）必须使用当前进程中最小可用的文件描述符号码，因此，在网络通信过程中稍不注意就有可能造成串话</p>
<table>
<thead>
<tr>
<th style="text-align:center">文件描述符</th>
<th style="text-align:center">用途</th>
<th style="text-align:center">POSIX名称</th>
<th style="text-align:center">stdio流</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">标准输入</td>
<td style="text-align:center">STDIN_FILENO</td>
<td style="text-align:center">stdin</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">标准输出</td>
<td style="text-align:center">STDOUT_FILENO</td>
<td style="text-align:center">stdout</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">标准错误</td>
<td style="text-align:center">STDERR_FILENO</td>
<td style="text-align:center">stderr</td>
</tr>
</tbody>
</table>
<h2 id="文件描述符与打开文件之间的关系"><a href="#文件描述符与打开文件之间的关系" class="headerlink" title="文件描述符与打开文件之间的关系"></a>文件描述符与打开文件之间的关系</h2><p>一个进程建立，会在进程表中建立对应的项，而这个进程项下包含了一个文件描述符表，在该进程中打开的文件描述符都会保存在这里。</p>
<p>一个进程打开一个文件，则会在文件描述符表、系统文件表、内存索引结点表中建立一些对应关系</p>
<p> <img src="/2018/01/05/文件描述符/屏幕快照 2018-01-05 下午5.16.25.png" alt="屏幕快照 2018-01-05 下午5.16.25"></p>
<p>进程A和进程B打开同一个文件（i-node 1976）,实际上两个不相干的进程打开同一个文件时，内核会在系统文件表中新建不同的项指向相同的内存索引节点，这时进程A和进程B的IO操作都是相对独立的互不影响，所以在实际操作时多个不同进程对同一个文件进行操作时会造成不同的读写操作被覆盖的情况</p>
<p>socket在进程中同样是一个文件描述符，但它是一个特殊文件类型，跟文件不一样，它不能通过一个具体路径去访问。</p>
<p>这里解释一下“惊群”,多个进程监听同一个socket ( fork可以实现多个进程监听同一个socket )，一开始多个进程同时在accept处阻塞，当有一个连接进入，多个进程同时被唤醒，去抢占accept到的资源，这个现象叫“惊群”。但是只有一个进程能成功accept，而不会同时有多个进程能拿到该连接对象，操作系统保证上述操作的安全性</p>
<p>参考链接：</p>
<p><a href="http://ju.outofmemory.cn/entry/104872" target="_blank" rel="noopener">http://ju.outofmemory.cn/entry/104872</a></p>
<p><a href="http://blog.csdn.net/cywosp/article/details/38965239" target="_blank" rel="noopener">http://blog.csdn.net/cywosp/article/details/38965239</a></p>
]]></content>
      
        <categories>
            
            <category> 系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 系统 </tag>
            
            <tag> 描述符 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SO_RCVLOWAT和SO_SNDLOWAT说明]]></title>
      <url>/2018/01/05/SO-RCVLOWAT%E5%92%8CSO-SNDLOWAT%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<h2 id="SO-RCVLOWAT-和-SO-SNDLOWAT定义"><a href="#SO-RCVLOWAT-和-SO-SNDLOWAT定义" class="headerlink" title="SO_RCVLOWAT 和 SO_SNDLOWAT定义"></a>SO_RCVLOWAT 和 SO_SNDLOWAT定义</h2><p>每个套接口（socket）都有一个接收低潮限度和一个发送低潮限度</p>
<p>接收低潮限度：对于TCP套接口而言，接收缓冲区中的数据必须达到规定数量，内核才通知进程“可读”。比如触发select或者epoll,返回套接口可读</p>
<p>发送低潮限度：对于TCP套接口而言，发送缓冲区中的空闲空间（可以写入数据的空间）大于低水位标记，系统才通知程</p>
<a id="more"></a>
<p>序可以往该socket上写入数据</p>
<p>对于接收低潮限度的理解：如果应用程序没有调用recv()去读取socket的接受缓冲区的数据，则接受缓冲区数据将一直保存在接受缓存区中，所以随着接受缓冲区接受到更多发送端发送缓冲区中的数据，则肯定会导致接受缓冲区溢出，所以设置一个接受低潮限度，当epoll监听到某一个socket的接收缓冲区的数据超过了接收低潮限度，则触发读就绪，使得epoll循环返回，开始处理I/O事件。</p>
<p>接收低潮限度：默认为1字节</p>
<p>对于发送低潮限度：如果应用程序没有调用send()来copy应用程序buff中的数据到socket发送缓冲区中，则随着发送缓冲区的数据被内核通过tcp协议发送出去，最后socket发送缓冲区的数据越来越少，可用的剩余空间越来越多，最后超过发送缓冲区的发送低潮限度，则epoll监听到这个socket可写，使得epoll循环返回，开始处理写I/O事件。</p>
<p>发送低潮限度：默认为2048字节</p>
<p>文中的epoll会在其他博客中解读</p>
<p>参考链接：<a href="http://blog.csdn.net/yygydjkthh/article/details/46853023" target="_blank" rel="noopener">http://blog.csdn.net/yygydjkthh/article/details/46853023</a></p>
]]></content>
      
        <categories>
            
            <category> 网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> socket </tag>
            
            <tag> 套接口 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AOF持久化]]></title>
      <url>/2018/01/04/AOF%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>AOF 持久化功能的实现可以分为命令追加、文件写入、文件同步三个步骤</p>
<h2 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h2><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的命令追加到服务器状态的aof_buf 缓冲区的末尾：</p>
<p>struct redisServer {</p>
<a id="more"></a>
<p>// AOF缓冲区</p>
<p>sds aof_buf;</p>
<p>}</p>
<p>举个例子，如果客户端向服务器发送以下命令：</p>
<p>redis&gt; SET KEY VALUE</p>
<p>OK</p>
<p>那么服务器在执行这个SET命令之后，会将以下协议内容追加到 aof_buf 缓冲区的末尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n</span><br></pre></td></tr></table></figure>
<h2 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h2><p>Redis 的服务器进程就是一个事件循环，这个循环中的文件事件负责接受客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像 serverCron 函数这样需要定时运行的函数</p>
<p>服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf 缓存区里面，在服务器每次结束一个事件循环之前，她都会调用 flushAppendOnlyFile 函数，考虑是否需要将 aof_buf 缓冲区中的内容写入和保存到 AOF文件里面，这个过程可以用一下伪代码表示：</p>
<p>def eventLoop():</p>
<p>​    while True:</p>
<p>​        // 处理文件事件，接收命令请求以及发送命令回复</p>
<p>​        // 处理命令请求时可能会有新内容被追加到aof_buf 缓冲区中</p>
<p>​        processFileEvents()</p>
<p>​        // 处理时间事件</p>
<p>​        processTimeEvents()</p>
<p>​        // 考虑是否要将 aof_buf 中的内容写入和保存到 AOF 文件里面</p>
<p>​        flushAppendOnlyFile()</p>
<p><code>flushAppendOnlyFile</code> 函数的行为由服务器配置的 <code>appendfsync</code> 选项的值来决定， 各个不同值产生的行为如表 TABLE_APPENDFSYNC 所示。</p>
<table>
<thead>
<tr>
<th><code>appendfsync</code> 选项的值</th>
<th><code>flushAppendOnlyFile</code> 函数的行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>always</code></td>
<td>将 <code>aof_buf</code> 缓冲区中的所有内容写入并同步到 AOF 文件。</td>
</tr>
<tr>
<td><code>everysec</code></td>
<td>将 <code>aof_buf</code> 缓冲区中的所有内容写入到 AOF 文件， 如果上次同步 AOF 文件的时间距离现在超过一秒钟， 那么再次对 AOF 文件进行同步， 并且这个同步操作是由一个线程专门负责执行的。</td>
</tr>
<tr>
<td><code>no</code></td>
<td>将 <code>aof_buf</code> 缓冲区中的所有内容写入到 AOF 文件， 但并不对 AOF 文件进行同步， 何时同步由操作系统来决定。</td>
</tr>
</tbody>
</table>
<p>如果用户没有主动为 <code>appendfsync</code> 选项设置值， 那么 <code>appendfsync</code> 选项的默认值为 <code>everysec</code> </p>
<p>当 <code>appendfsync</code> 的值为 <code>always</code> 时， 服务器在每个事件循环都要将 <code>aof_buf</code> 缓冲区中的所有内容写入到 AOF 文件， 并且同步 AOF 文件， 所以 <code>always</code> 的效率是 <code>appendfsync</code> 选项三个值当中最慢的一个， 但从安全性来说， <code>always</code> 也是最安全的， 因为即使出现故障停机， AOF 持久化也只会丢失一个事件循环中所产生的命令数据。</p>
<p>当 <code>appendfsync</code> 的值为 <code>everysec</code> 时， 服务器在每个事件循环都要将 <code>aof_buf</code> 缓冲区中的所有内容写入到 AOF 文件， 并且每隔超过一秒就要在子线程中对 AOF 文件进行一次同步： 从效率上来讲， <code>everysec</code> 模式足够快， 并且就算出现故障停机， 数据库也只丢失一秒钟的命令数据。</p>
<p>当 <code>appendfsync</code> 的值为 <code>no</code> 时， 服务器在每个事件循环都要将 <code>aof_buf</code> 缓冲区中的所有内容写入到 AOF 文件， 至于何时对 AOF 文件进行同步， 则由操作系统控制。</p>
<p>在执行BGREWRITEAOF命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件的期间记录服务期执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</p>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RDB持久化]]></title>
      <url>/2018/01/03/RDB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="RDB文件的创建"><a href="#RDB文件的创建" class="headerlink" title="RDB文件的创建"></a>RDB文件的创建</h2><h3 id="1-save和bgsave"><a href="#1-save和bgsave" class="headerlink" title="1.save和bgsave"></a>1.save和bgsave</h3><p>​    save命令会阻塞redis服务器的进程，直到RDB文件创建为止，在服务器进程阻塞期间，服务器不能处理任何命令请求</p>
<p>​    bgsave命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</p>
<a id="more"></a>
<h3 id="2-自动间隔性保存"><a href="#2-自动间隔性保存" class="headerlink" title="2.自动间隔性保存"></a>2.自动间隔性保存</h3><p>redis允许用户通过设置服务器的配置文件redis.conf文件中的save选项，让服务器每隔一段时间自动执行一次bgsave命令。比如：</p>
<p>​    save 900 1       /<em> 服务器在900秒之内，对数据库进行了至少1次修改 </em>/</p>
<p>​    save 300 10    /<em> 服务器在300秒之内，对数据库进行了至少10次修改 </em>/</p>
<p>​    save 60 1000  /<em> 服务器在60秒之内，对数据库进行了至少1000次修改 </em>/</p>
<p>原理：</p>
<p>​    服务器会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性，该属性是一个数组，数组中每个元素都是一个saveparams结构，每个结构都保存了一个save选项设置的保存条件。</p>
<p>​    服务器状态还维持着一个dirty计数器，以及一个lastsave属性</p>
<p>​    dirty计数器记录距离上一次成功执行save命令或者bgsave命令之后，服务器对数据库状态进行了多少次修改</p>
<p>​    lastsave属性是一个Unix时间戳，记录了服务器上一次成功执行save命令或者bgsave命令的时间</p>
<h2 id="RDB文件的载入"><a href="#RDB文件的载入" class="headerlink" title="RDB文件的载入"></a>RDB文件的载入</h2><p>​    RDB文件的载入工作是在服务器启动时自动执行的，没有专门用于载入RDB文件的命令，只要redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止</p>
<h2 id="RDB文件的结构"><a href="#RDB文件的结构" class="headerlink" title="RDB文件的结构"></a>RDB文件的结构</h2><p> <img src="/2018/01/03/RDB文件结构/20180104.png" alt="20180104"></p>
<p>RDB文件结构如上：</p>
<p>RDB文件的最开头是REDIS部分，这个部分的长度是5字节，保存着“REDIS”五个字符。通过这五个字符，程序可以在载入文件的时候，快速检查所载入的文件是否是RDB文件</p>
<p>db_version 长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如“006”就代表RDB文件的版本为第六版</p>
<p>datebases 的结构就是上图中的：</p>
<p> <img src="/2018/01/03/RDB文件结构/2018010401.png" alt="2018010401"></p>
<p>datebases 是由多个该结构组成</p>
<p>SELECTDB 常量的长度为1字节，当读入程序遇到这个值的时候，它就知道接下来要读入的将是一个数据库号码</p>
<p>db_number 保存着一个数据库的号码，根据号码的大小不同，这个部分的长度可以是1字节、2字节或者5字节。当程序读入db_number部分之后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中</p>
<p>key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。key_value_pairs结构如下：</p>
<p>​    不带过期时间的键值对结构如下：</p>
<p>​     <img src="/2018/01/03/RDB文件结构/2018010402.png" alt="2018010402"></p>
<p>​    带过期时间的键值对结构如下：</p>
<p> <img src="/2018/01/03/RDB文件结构/2018010403.png" alt="2018010403"></p>
<p>​    key_value_pair中key总是一个字符串对象，它的编码方式是REDIS_RDB_TYPE_STRING类型的</p>
<p>​    value的编码：</p>
<p>​        字符串对象：字符串对象的编码可以是REDIS_ENCODING_INT 或者 REDIS_ENCODING_RAW，如果是REDIS_ENCODING_INT 那么说明对象保存的是长度不超过32位的整数，REDIS_ENCODING_INT的值可以是REDIS_RDB_ENC_INT8、REDIS_RDB_ENC_INT16、REDIS_RDB_ENC_INT32,分别代表8位、16位、32位的整数值integer；如果是REDIS_ENCODING_RAW 那么说明对象保存的是一个字符串值，根据字符串长度的不同，有压缩和不压缩两种方法来保存这个字符串：如果字符串的长度小于等于20字节，那么这个字符串会直接被原样保存。如果字符串的长度大于20字节，那么这个字符串会被压缩之后再保存</p>
<p>​    无压缩字符串保存结构如下：</p>
<p>​         <img src="/2018/01/03/RDB文件结构/2018010404.png" alt="2018010404"></p>
<p>​    被压缩后的字符串，保存结构如下：</p>
<p> <img src="/2018/01/03/RDB文件结构/2018010405.png" alt="2018010405"></p>
<p>​    REDIS_RDB_ENC_LZF 常量标志着字符串已经被LZF算法压缩过了，compressed_len记录的是字符串被压缩之后的长度，而origin_len记录的是字符串原来的长度，compressed_string记录的则是被压缩之后的字符串</p>
<p>​        </p>
<p>​    列表对象：TYPE的值为REDIS_RDB_TYPE_LIST，value保存的就是REDIS_ENCODING_LINKEDLIST编码的列表对象，结构如下图： <img src="/2018/01/03/RDB文件结构/2018010406.png" alt="2018010406"></p>
<p>​        结构中的第一个数字3是列表的长度，之后跟着的分别是第一个列表项、第二个列表项和第三个列表项</p>
<p>​            第一个列表项的长度为5，内容为字符串“hello”</p>
<p>​    集合对象：TYPE的值为REDIS_RDB_TYPE_SET，value保存的就是一个REDIS_ENCODING_HT 编码的集合对象，RDB文件保存这种对象的结构如下： <img src="/2018/01/03/RDB文件结构/2018010407.png" alt="2018010407"></p>
<p>结构中的第一个数字4记录了集合的大小，之后跟着的是集合的四个元素：</p>
<p>​    第一个元素的长度为5，值为“apple”</p>
<p>​    哈希表对象：TYPE的值为REDIS_RDB_TYPE_HASH，那么value 保存的就是一个REDIS_ENCODING_HT 编码的集合对象，RDB 文件保存的结构如下： <img src="/2018/01/03/RDB文件结构/2018010408.png" alt="2018010408"></p>
<p>这个示例结构中，第一个数字2记录了哈希表的键值对数量，之后跟着的是两个键值对：</p>
<p>​    第一个键值对的键的长度是1的字符串“a”，值是长度为5的字符串“apple”</p>
<p>​    有序集合对象：TYPE的值为REDIS_RDB_TYPE_ZSET，value保存的是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象，结构如下： <img src="/2018/01/03/RDB文件结构/2018010409.png" alt="2018010409"></p>
<p>在这个示例结构中，第一个数字2记录了有序集合的元素数量，之后跟着的是两个有序集合元素：</p>
<p>​    第一个元素的成员是长度为2的字符串“pi”，分值被转换成字符串之后变成了长度为4的字符串“3.14”</p>
<p>​    INTSET编码集合：TYPE的值为REDIS_RDB_TYPE_SET_INTSET，那么value保存的就是一个整数集合对象，RDB文件保存这种对象的方法是，先将整数集合转换为字符串对象，然后将这个字符串对象保存到RDB文件里面</p>
<p>如果程序读入RDB文件的过程中，碰到由整数集合对象转换成的字符串对象，那么程序会根据TYPE值的表示，先读入字符串对象，再将这个字符串对象转换成原来的整数集合对象</p>
<p>​    ZIPLIST 编码的列表、哈希表或者有序集合：TYPE的值为 <code>REDIS_RDB_TYPE_LIST_ZIPLIST</code> 、 <code>REDIS_RDB_TYPE_HASH_ZIPLIST</code> 或者 REDIS_RDB_TYPE_ZSET_ZIPLIST ， 那么 <code>value</code> 保存的就是一个压缩列表对象， RDB 文件保存这种对象的方法是：</p>
<ol>
<li>将压缩列表转换成一个字符串对象。</li>
<li>将转换所得的字符串对象保存到 RDB 文件。</li>
</ol>
<p>如果程序在读入 RDB 文件的过程中， 碰到由压缩列表对象转换成的字符串对象， 那么程序会根据 <code>TYPE</code> 值的指示， 执行以下操作：</p>
<ol>
<li>读入字符串对象，并将它转换成原来的压缩列表对象。</li>
<li>根据 <code>TYPE</code> 的值，设置压缩列表对象的类型： 如果 <code>TYPE</code> 的值为 <code>REDIS_RDB_TYPE_LIST_ZIPLIST</code> ， 那么压缩列表对象的类型为列表； 如果<code>TYPE</code> 的值为 <code>REDIS_RDB_TYPE_HASH_ZIPLIST</code> ， 那么压缩列表对象的类型为哈希表； 如果 <code>TYPE</code> 的值为 <code>REDIS_RDB_TYPE_ZSET_ZIPLIST</code> ， 那么压缩列表对象的类型为有序集合。</li>
</ol>
<p>从步骤 2 可以看出， 由于 <code>TYPE</code> 的存在， 即使列表、哈希表和有序集合三种类型都使用压缩列表来保存， RDB 读入程序也总可以将读入并转换之后得出的压缩列表设置成原来的类型。</p>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis数据库结构和操作]]></title>
      <url>/2018/01/03/redis%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h2><p>typedef struct redisDb {</p>
<p>// 数据库键空间，保存着数据库中的所有键值对</p>
<p>dict *dict;</p>
<p>} redisDb;</p>
<a id="more"></a>
<p>Redis 是一个键值对数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间</p>
<p>键空间的键也就是数据库的键，每个键都是一个字符串对象</p>
<p>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象在内的任意一种Redis对象</p>
<h2 id="Redis-操作"><a href="#Redis-操作" class="headerlink" title="Redis 操作"></a>Redis 操作</h2><p>添加新键 SET str “message”</p>
<p>删除新键 DEL book（Redis使用惰性删除和定期删除两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间，主动查询并删除过期键）</p>
<p>更新键 SET str “description”</p>
<p>对键取值 GET str</p>
<p>清空数据库 FLUSHDB</p>
<p>从键空间随机获得一个键 RANDOMKEY</p>
<p>查询数据库键数量 DBSIZE</p>
<p>还有EXIST、RENAME、KEYS，等等</p>
<h2 id="读取键空间时的维护操作"><a href="#读取键空间时的维护操作" class="headerlink" title="读取键空间时的维护操作"></a>读取键空间时的维护操作</h2><p>当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，其中包括：</p>
<ol>
<li>在读取一个键之后（读和写操作都要对键进行读取），服务器会根据键是否存在，以此来更新服务器的键空间命中次数和键空间不命中次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看</li>
<li>在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用命令OBJECT idletime命令可以查看键key的闲置时间</li>
<li>如果服务器在读取一个键时，发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作</li>
<li>如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏，从而让事物程序注意到这个键已经被修改过</li>
<li>服务器每修改一个键之后，都会对脏键计数器的值增一，这个计数器会触发服务器的持久化以及复制操作执行</li>
<li>如果服务器开启了数据库通知通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知</li>
</ol>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis数据结构]]></title>
      <url>/2017/12/28/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1.简单动态字符串"></a>1.简单动态字符串</h1><p>Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS作为字符串表示。</p>
<h2 id="SDS结构"><a href="#SDS结构" class="headerlink" title="SDS结构"></a>SDS结构</h2><p>struct sdshdr{</p>
<pre><code>// 记录buf数组中已使用字节的数量
</code></pre><a id="more"></a>
<pre><code> // 等于SDS所保存字符串的长度

 int len;

 // 记录buf数组中未使用字节的数量

 int free;

// 字节数组，用于保存字符串

char buf[];
</code></pre><p>};</p>
<p>  <img src="/2017/12/28/redis数据结构/2017122801.png" alt="2017122801"></p>
<p>如上图展示：</p>
<p>free 属性的值为0，表示这个SDS没有分配任何未使用空间</p>
<p>len 属性的值为5，表示这个SDS保存了一个5字节长的字符串</p>
<p>buf 属性是一个char类型的数组，数组的前5个字节分别保存了’R’、’e’、’d’、’i’、’s’这五个字符，而最后一个字节则保存了空字符’\0’。</p>
<h2 id="跟C字符串相比，SDS具有以下优点"><a href="#跟C字符串相比，SDS具有以下优点" class="headerlink" title="跟C字符串相比，SDS具有以下优点"></a>跟C字符串相比，SDS具有以下优点</h2><ol>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串长度时所需的内存重分配次数</li>
<li>二进制安全（后期看源码解释）（维基百科对二进制安全的定义：<a href="https://en.wikipedia.org/wiki/Binary-safe" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Binary-safe</a>）</li>
<li>兼容部分C字符串函数</li>
</ol>
<h1 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h1><p>当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。</p>
<h3 id="链表节点的结构"><a href="#链表节点的结构" class="headerlink" title="链表节点的结构"></a>链表节点的结构</h3><p>typedef struct listNode{</p>
<pre><code>    // 前置结点

   struct listNode *prev;

  // 后置结点

  struct listNode *next;

// 节点的值

void *value;
</code></pre><p>}listNode;</p>
<h3 id="链表的结构"><a href="#链表的结构" class="headerlink" title="链表的结构"></a>链表的结构</h3><p>typedef struct list{</p>
<pre><code>    // 表头节点

   listNode *head;

  // 表尾节点

  listNode *tail;

 // 链表所包含的节点数量

  unsigned long len;

// 节点值复制函数

 void *( *dup)(void *ptr);

//节点值释放函数

 void *( *free)(void *ptr);

//节点值对比函数

 void *( *match)(void *ptr,void *key)
</code></pre><p>}list;</p>
<h3 id="链表的特性"><a href="#链表的特性" class="headerlink" title="链表的特性"></a>链表的特性</h3><ol>
<li>链表被广泛用于实现Redis的各种功能，比如列表键，发布与订阅，慢查询，监视器，等等</li>
<li>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表</li>
<li>每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息</li>
<li>因为链表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表</li>
<li>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值</li>
</ol>
<h1 id="3-字典"><a href="#3-字典" class="headerlink" title="3.字典"></a>3.字典</h1><p>Redis 的字典使用哈希表作为底层实现，一个哈希表里面可以有很多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p>
<h3 id="哈希表的结构"><a href="#哈希表的结构" class="headerlink" title="哈希表的结构"></a>哈希表的结构</h3><p>typedef struct dictht{</p>
<pre><code>   // 哈希表数组

  dictEntry **table;

  // 哈希表大小

 unsigned long size;

  //哈希表大小掩码，用于计算索引值

 //总是等于size -1

 unsigned long sizemask;

 //该哈希表已有节点的数量

unsigned long used;
</code></pre><p>}dictht;</p>
<h3 id="哈希表节点的结构"><a href="#哈希表节点的结构" class="headerlink" title="哈希表节点的结构"></a>哈希表节点的结构</h3><p>typedef struct dictEntry{</p>
<pre><code>   // 键

   void *key;

 // 值

 union {

        void *val;

        uint64_t u64;

        int64_t  s64;

} v;

// 指向下个哈希表节点，形成链表

struct dictEntry *next;
</code></pre><p>} dictEntry;</p>
<h3 id="字典的结构"><a href="#字典的结构" class="headerlink" title="字典的结构"></a>字典的结构</h3><p>typedef struct dict{</p>
<pre><code>   // 类型特定函数

  dictType *type;

  // 私有数据

  void *privdata;

  // 哈希表

  dictht ht[2];

 // rehash 索引

// 当rehash 不在进行时，值为 -1

int rehashidx; /* rehashing not in progress if rehashidx == -1 */
</code></pre><p>} dict;</p>
<p>type属性是一个指向 dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</p>
<p>例如：</p>
<p>typedef struct dictType{</p>
<pre><code>    // 计算哈希值的函数

    unsigned int ( *hashFunction) (const void *key);

   // 复制键的函数

   void *( *keyDup) (void *privdata,const void *key);

  // 复制值的函数

  void *( *valDup) (void *privdata,const void *obj);

 // 对比键的函数

 int ( *keyCompare) (void *privdata,const void *key1,const void *key2);

// 销毁键的函数

 void ( *keyDestructor) (void *privdata,void *key);

// 销毁值的函数

void ( *valDestructor) (void *privdata,void *obj);
</code></pre><p>} dictType;</p>
<p>ht 属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对 ht[0] 哈希表进行rehash时使用</p>
<p>rehashidx:记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为 -1；</p>
<p>如下图展示了一个普通状态下（没有进行rehash）的字典：</p>
<p> <img src="/2017/12/28/redis数据结构/2017122803.png" alt="2017122803"></p>
<h3 id="字典的特性"><a href="#字典的特性" class="headerlink" title="字典的特性"></a>字典的特性</h3><ol>
<li>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希表</li>
<li>Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个用于平时使用，另一个仅在进行rehash时使用。</li>
<li>当字典被用作数据库的底层实现，或者哈希表的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值</li>
<li>哈希值使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接一个单项链表</li>
<li>在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性完成的，而是渐进式地完成的。</li>
</ol>
<h1 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4.跳跃表"></a>4.跳跃表</h1><p>跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均O(logN)最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p>
<h3 id="跳跃表的结构"><a href="#跳跃表的结构" class="headerlink" title="跳跃表的结构"></a>跳跃表的结构</h3><p>节点：</p>
<p>typedef struct zskiplistNode{</p>
<pre><code>    // 后退指针

   struct zskiplistNode *backward;

  // 分值

  double score;

  // 成员对象

  robj *obj;

 // 层

 struct zskiplistLevel{

           // 前进指针

          struct zskiplistNode *forward;

          // 跨度

          unsigned int span;

}level[];
</code></pre><p>}zskiplistNode;</p>
<p>list:</p>
<p>typedef struct zskiplist{</p>
<pre><code>   // 表头节点和表尾节点

  struct zskiplistNode ***header,\***tail;

 // 表中节点的数量

 unsigned long length;

// 表中层数最大的节点的层数

 int level;
</code></pre><p>}zskiplist;</p>
<p>结构如下图：</p>
<p> <img src="/2017/12/28/redis数据结构/2017122802.png" alt="2017122802"></p>
<h3 id="跳跃表的特性"><a href="#跳跃表的特性" class="headerlink" title="跳跃表的特性"></a>跳跃表的特性</h3><ol>
<li>跳跃表是有序集合的底层实现之一， 除此之外它在 Redis 中没有其他应用</li>
<li>Redis 的跳跃表实现由 <code>zskiplist</code> 和 <code>zskiplistNode</code> 两个结构组成， 其中 <code>zskiplist</code> 用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而 <code>zskiplistNode</code> 则用于表示跳跃表节点</li>
<li>每个跳跃表节点的层高都是 <code>1</code> 至 <code>32</code> 之间的随机数</li>
<li>在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的</li>
<li>跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序</li>
</ol>
<h1 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5.整数集合"></a>5.整数集合</h1><p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现</p>
<h3 id="整数集合的结构"><a href="#整数集合的结构" class="headerlink" title="整数集合的结构"></a>整数集合的结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line"></span><br><span class="line">    // 编码方式（int8_t int16_t int32_t int64_t）</span><br><span class="line">    uint32_t encoding;</span><br><span class="line"></span><br><span class="line">    // 集合包含的元素数量</span><br><span class="line">    uint32_t length;</span><br><span class="line"></span><br><span class="line">    // 保存元素的数组</span><br><span class="line">    int8_t contents[];</span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p> <img src="/2017/12/28/redis数据结构/2017122804.png" alt="2017122804"></p>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p>升级整数集合并添加新元素共分为三步进行：</p>
<ol>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ol>
<h3 id="整数集合的特性"><a href="#整数集合的特性" class="headerlink" title="整数集合的特性"></a>整数集合的特性</h3><ul>
<li>整数集合是集合键的底层实现之一。</li>
<li>整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。</li>
<li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。</li>
<li>整数集合只支持升级操作， 不支持降级操作</li>
</ul>
<h1 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6.压缩列表"></a>6.压缩列表</h1><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。</p>
<p>当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现</p>
<h3 id="列表的结构"><a href="#列表的结构" class="headerlink" title="列表的结构"></a>列表的结构</h3><p>表 7-1 压缩列表各个组成部分的详细说明</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>zlbytes</code></td>
<td><code>uint32_t</code></td>
<td><code>4</code> 字节</td>
<td>记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 <code>zlend</code> 的位置时使用。</td>
</tr>
<tr>
<td><code>zltail</code></td>
<td><code>uint32_t</code></td>
<td><code>4</code> 字节</td>
<td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td>
</tr>
<tr>
<td><code>zllen</code></td>
<td><code>uint16_t</code></td>
<td><code>2</code> 字节</td>
<td>记录了压缩列表包含的节点数量： 当这个属性的值小于 <code>UINT16_MAX</code> （<code>65535</code>）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 <code>UINT16_MAX</code> 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td><code>entryX</code></td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td><code>zlend</code></td>
<td><code>uint8_t</code></td>
<td><code>1</code> 字节</td>
<td>特殊值 <code>0xFF</code> （十进制 <code>255</code> ），用于标记压缩列表的末端。</td>
</tr>
</tbody>
</table>
<h3 id="列表节点的结构"><a href="#列表节点的结构" class="headerlink" title="列表节点的结构"></a>列表节点的结构</h3><p>节点的 <code>previous_entry_length</code> 属性以字节为单位， 记录了压缩列表中前一个节点的长度。</p>
<p><code>previous_entry_length</code> 属性的长度可以是 <code>1</code> 字节或者 <code>5</code> 字节：</p>
<ul>
<li>如果前一节点的长度小于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性的长度为 <code>1</code> 字节： 前一节点的长度就保存在这一个字节里面。</li>
<li>如果前一节点的长度大于等于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性的长度为 <code>5</code> 字节： 其中属性的第一字节会被设置为 <code>0xFE</code>（十进制值 <code>254</code>）， 而之后的四个字节则用于保存前一节点的长度。</li>
</ul>
<p>节点的 <code>encoding</code> 属性记录了节点的 <code>content</code> 属性所保存数据的类型以及长度：</p>
<ul>
<li>一字节、两字节或者五字节长， 值的最高位为 <code>00</code> 、 <code>01</code> 或者 <code>10</code> 的是字节数组编码： 这种编码表示节点的 <code>content</code> 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；</li>
<li>一字节长， 值的最高位以 <code>11</code> 开头的是整数编码： 这种编码表示节点的 <code>content</code> 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；</li>
</ul>
<p>节点的 <code>content</code> 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 <code>encoding</code> 属性决定。</p>
<h3 id="压缩列表的特性"><a href="#压缩列表的特性" class="headerlink" title="压缩列表的特性"></a>压缩列表的特性</h3><ul>
<li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li>
<li>压缩列表被用作列表键和哈希键的底层实现之一。</li>
<li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li>
<li>添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。</li>
</ul>
<h1 id="7-对象"><a href="#7-对象" class="headerlink" title="7.对象"></a>7.对象</h1><ul>
<li>Redis 数据库中的每个键值对的键和值都是一个对象。</li>
<li>Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
<li>服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。</li>
<li>Redis 的对象系统带有引用计数实现的内存回收机制， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。</li>
<li>Redis 会共享值为 <code>0</code> 到 <code>9999</code> 的字符串对象。</li>
<li>对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的空转时间</li>
</ul>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[状态模式]]></title>
      <url>/2017/12/27/2017-12-20--%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>状态模式介绍</p>
<p>在运行时，当一个对象的内在状态改变时其行为也发生大的改变，这个对象看起来像是改变了其类；抑或一个操作中含有庞大的多分支结构，并且这些分支决定于对象的状态。这种情况就可以使用状态模式来设计编程，把状态的判断逻辑转移到表示不同的一系列类当中，使代码看起来更加简洁清晰。</p>
<h3 id="状态模式的角色"><a href="#状态模式的角色" class="headerlink" title="状态模式的角色"></a>状态模式的角色</h3><a id="more"></a>
<p>（1）上下文环境（Context）：它定义了客户程序需要的接口并维护一个具体状态角色的实例，将与状态相关的操作委托给当前的Concrete State对象来处理。</p>
<p>（2）抽象状态角色（State）：定义一个接口以封装使用上下文环境的一个特定状态相关的行为。</p>
<p>（3）具体状态角色（Concrete State）：实现抽象状态定义的接口。</p>
<h3 id="状态模式代码示例"><a href="#状态模式代码示例" class="headerlink" title="状态模式代码示例"></a>状态模式代码示例</h3><p>/// <summary></summary></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Context类，维护一个ConcreteState子类的实例，这个实例定义当前的状态。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">    <span class="comment">/// 定义Context的初始状态</span></span><br><span class="line">    <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">    <span class="comment">/// &lt;param name="state"&gt;&lt;/param&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(State state)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">    <span class="comment">/// 可读写的状态属性，用于读取和设置新状态</span></span><br><span class="line">    <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">    <span class="keyword">public</span> State State</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">        set &#123; state = value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">    <span class="comment">/// 对请求做处理，并设置下一个状态</span></span><br><span class="line">    <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        state.Handle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 抽象状态类，定义一个接口以封装与Context的一个特定状态相关的行为</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 具体状态类，每一个子类实现一个与Context的一个状态相关的行为</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">public class ConcreteStateA : State</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">    <span class="comment">/// 设置ConcreteStateA的下一个状态是ConcreteStateB</span></span><br><span class="line">    <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">    <span class="comment">/// &lt;param name="context"&gt;&lt;/param&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"当前状态是 A."</span>);</span><br><span class="line">        context.State = <span class="keyword">new</span> ConcreteStateB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStateB : State</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">    <span class="comment">/// 设置ConcreteStateB的下一个状态是ConcreteSateA</span></span><br><span class="line">    <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">    <span class="comment">/// &lt;param name="context"&gt;&lt;/param&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"当前状态是 B."</span>);</span><br><span class="line">        context.State = <span class="keyword">new</span> ConcreteStateA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 设置Context的初始状态为ConcreteStateA</span></span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStateA());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不断地进行请求，同时更改状态</span></span><br><span class="line">        context.Request();</span><br><span class="line">        context.Request();</span><br><span class="line">        context.Request();</span><br><span class="line">        context.Request();</span><br><span class="line"></span><br><span class="line">        Console.Read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM调优之jstack找出最耗cpu的线程并定位代码]]></title>
      <url>/2017/11/30/2017-11-30--JVM%E8%B0%83%E4%BC%98%E4%B9%8Bjstack%E6%89%BE%E5%87%BA%E6%9C%80%E8%80%97cpu%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%AE%9A%E4%BD%8D%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>第一步：先找出java的进程Id(PID) 假设java应用名称是zcg_commodity</p>
<p>ps -ef|grep zcg_commodity</p>
<p><img src="data:image/png;base64,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" alt="img"></p>
<p>得到进程Id为32464</p>
<a id="more"></a>
<p>第二步：找出该进程内最消耗CPU的线程</p>
<p>top -Hp pid</p>
<p>输入top -Hp 32464</p>
<p><img src="data:image/png;base64,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" alt="img"></p>
<p>TIME列就是各个java线程耗费的CPU的时间，比如图中是线程ID的为2012的线程，</p>
<p>通过 printf “%x\n” 2012</p>
<p>得到2012的十六进制为 7dc</p>
<p>第三步：</p>
<p>一般会进到jdk的bin目录下，root权限执行</p>
<p>jstack 32464|grep 7dc</p>
<p>PollIntervalRetrySchedulerThread” prio=10 tid=0x00007f950043e000 nid=0x54ee in Object.wait()</p>
<p>定位问题所在</p>
<p>之前有遇到前几个消耗CPU的线程都是GC的，那可能是短时间内存泄露严重，导致GC回收不过来，导致CPU短时间飙升</p>
<p>这种情况用jmap -histo:live 32464 |head -20，查看哪个对象生成异常，就可以定位问题大方向</p>
<p>第四步：</p>
<p>查代码</p>
]]></content>
      
        <categories>
            
            <category> 调优 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 调优 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM内存模型]]></title>
      <url>/2017/11/30/2017-11-30--JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h3 id="程序计数器（线程私有的）"><a href="#程序计数器（线程私有的）" class="headerlink" title="程序计数器（线程私有的）"></a>程序计数器（线程私有的）</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<a id="more"></a>
<p>由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<h3 id="虚拟机栈（线程私有的）"><a href="#虚拟机栈（线程私有的）" class="headerlink" title="虚拟机栈（线程私有的）"></a>虚拟机栈（线程私有的）</h3><p>虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。</p>
<p>动画是由一帧一帧图片连续切换结果的结果而产生的，其实虚拟机的运行和动画也类似，每个在虚拟机中运行的程序也是由许多的帧的切换产生的结果，只是这些帧里面存放的是方法的局部变量，操作数栈，动态链接，方法返回地址和一些额外的附加信息组成。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>对于执行引擎来说，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。</p>
<h3 id="java堆（线程共享的，生命周期与虚拟机相同）"><a href="#java堆（线程共享的，生命周期与虚拟机相同）" class="headerlink" title="java堆（线程共享的，生命周期与虚拟机相同）"></a>java堆（线程共享的，生命周期与虚拟机相同）</h3><p>保存对象实例，所有对象实例（包括数组）都要在堆上分配</p>
<h3 id="方法区（线程共享）"><a href="#方法区（线程共享）" class="headerlink" title="方法区（线程共享）"></a>方法区（线程共享）</h3><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p>
]]></content>
      
        <categories>
            
            <category> JVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jstack及dump文件分析]]></title>
      <url>/2017/11/30/2017-11-30--jstack%E5%8F%8Adump%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>jstack命令的用法为jstack pid</p>
<p>jstack在jdk/bin的目录下</p>
<p>在实际运行中，建议产生3次以上的dump文件，每次间隔10s左右，文件一起分析来能定位问题，不要拿一次的dump文件来分析问题，没有什么参考性。</p>
<p>dump文件中的线程状态值有：</p>
<a id="more"></a>
<p>1.死锁，Deadlock</p>
<p>2.执行中，Runnable</p>
<p>3.等待资源，Waiting on condition</p>
<p>4.等待获取监视器，Waiting on monitor entry</p>
<p>5.暂停，Suspended</p>
<p>6.对象等待中，Object.wait()或TIMED_WAITING</p>
<p>7.阻塞，Blocked</p>
<p>8.停止，Parked</p>
<p>含义分析如下：</p>
<p>1.Deadlock:死锁线程，一般指多个线程调用间，进入相互资源占用，导致一直等待无法释放的情况。</p>
<p>2.Runable:一般指该线程正在执行状态中，该线程占用了资源，正在处理某个请求，有可能正在传递SQL到数据库执行，有可能在对某个文件进行操作，有可能进行数据类型转换。</p>
<p>3.Waiting on condition:等待资源，或等待某个条件的发生。具体原因需结合stacktrace来分析。</p>
<pre><code>如果堆栈信息明确是应用代码，则证明该线程正在等待资源。一般是大量读取某资源，且该资源采用了资源锁的情况下，线程进入了等待状态，等待资源的读取。

或正在等待其他现场的执行

如果发现有大量的线程都处在Wait on Condition，从线程的stack看，正等待网络读写，这可能是一个网络瓶颈的征兆，是因为网络阻塞导致线程无法执行，一种情况是网络非常忙，几乎消耗了所有带宽，仍然有大量的数据等待网络读写；另一种情况也可能是网络空闲，但由于路由等问题，导致包无法正常的到达。

又或者是该线程在sleep,等待sleep的时间到了，将被唤醒
</code></pre><p>4.Blocked：线程阻塞，是指当前线程执行过程中，所需要的资源长时间等待却一直未能获取到，被容器的线程管理器表示为阻塞状态，可以理解为等待资源超时的线程。</p>
<p>5.Waiting for monitor entry 和 in Object.wait(): monitor是java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者Class的锁。每一个对象都有且只有一个monitor。当某个线程期待获得Monitor及对象的锁，而在锁被其他线程拥有的时候，这个线程就会进入Entry Set区域。曾经获得过锁，但是其他必要条件不满足而需要wait的线程就进入了Wait Set区域。</p>
<p>举例分析：</p>
<p>Waiting to lock 和 Blocked</p>
<p>实例：</p>
<p>“RMI TCP Connection(267865)-172.16.5.25” daemon prio=10 tid=0x00007fd508371000 nid=0x55ae  waiting for monitor entry [0x00007fd4f8684000]</p>
<p>   java.lang.Thread.State:  BLOCKED (on object monitor)</p>
<p>at org.apache.log4j.Category.callAppenders(Category.java:201)</p>
<ul>
<li>waiting to lock <0x00000000acf4d0c0> (a org.apache.log4j.Logger)</0x00000000acf4d0c0></li>
</ul>
<p>at org.apache.log4j.Category.forcedLog(Category.java:388)</p>
<p>at org.apache.log4j.Category.log(Category.java:853)</p>
<p>at org.apache.commons.logging.impl.Log4JLogger.warn(Log4JLogger.java:234)</p>
<p>at com.tuan.core.common.lang.cache.remote.SpyMemcachedClient.get(SpyMemcachedClient.java:110)</p>
<p>分析：</p>
<p>1）线程状态时Blocked，即阻塞状态。说明线程等待资源超时！</p>
<p>2）“waiting to lock<0x00000000acf4d0c0>”指的是线程在等待给这个0x00000000acf40c0地址上锁。</0x00000000acf4d0c0></p>
<p>3）如果在dump日志里查找字符串0x00000000acf40c0,发现有大量的线程在等待给这个地址上锁。如果能找到dump日志里哪个线程获得了这个锁，然后在我们自己打印的log中查到该线程，就能定位到具体位置。</p>
<p>4）”waiting for monitor entry”说明此线程通过synchronized(obj){……}申请进入临界区，进入到了Entry Set队列，但该obj对应的monitor被其他线程拥有，所以本线程在Entry Set中等待。</p>
<p>5）第一行里，“RMI TCP Connection(267865)-172.16.5.25”是Thread Name。tid 指java Thread id。nid 指native线程的id。prio是线程的优先级。[0x00007fd4f8684000]是线程栈起始地址。</p>
<p>示例二：Waiting on condition 和 TIME_WAITING</p>
<p>示例：</p>
<p>“RMI TCP Connection(idle)” daemon prio=10 tid=0x00007fd50834e800 nid=0x56b2  waiting on condition [0x00007fd4f1a59000]</p>
<p>   java.lang.Thread.State:  TIMED_WAITING (parking)</p>
<p>at sun.misc.Unsafe.park(Native Method)</p>
<ul>
<li>parking to wait for  <0x00000000acd84de8> (a java.util.concurrent.SynchronousQueue$TransferStack)</0x00000000acd84de8></li>
</ul>
<p>at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)</p>
<p>at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:424)</p>
<p>at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:323)</p>
<p>at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:874)</p>
<p>at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:945)</p>
<p>at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)</p>
<p>at java.lang.Thread.run(Thread.java:662)</p>
<p>1)“TIME_WAITING(parking)”中的time_waiting指等待状态，但这里指定了时间，到达指定时间后自动退出等待状态；parking指线程处于挂起中。</p>
<p>2）“waiing on condition”需要与堆栈中的“parking to wait for <0x00000000acd84de8>(a java.util.concurrent.SynchronousQueue$TransferStack) ”结合来看。首先，本线程肯定是在等待某个条件的发生，来把自己唤醒。其次，SynchronousQueue并不是一个队列，只是线程之间移交信息的机制，当我们把一个元素放入到SynchronousQueue中时必须有另一个线程正在等待接收移交的任务，因此这就是本线程在等待的条件。</0x00000000acd84de8></p>
<p>示例三：in Object.wait() 和 TIMED_WAITING</p>
<p>示例如下：</p>
<p>“RMI RenewClean-[172.16.5.19:28475]” daemon prio=10 tid=0x0000000041428800 nid=0xb09  in Object.wait() [0x00007f34f4bd0000]</p>
<p>   java.lang.Thread.State:  TIMED_WAITING (on object monitor)</p>
<p>at java.lang.Object.wait(Native Method)</p>
<ul>
<li>waiting on <0x00000000aa672478> (a java.lang.ref.ReferenceQueue$Lock)</0x00000000aa672478></li>
</ul>
<p>at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:118)</p>
<ul>
<li>locked <0x00000000aa672478> (a java.lang.ref.ReferenceQueue$Lock)</0x00000000aa672478></li>
</ul>
<p>at sun.rmi.transport.DGCClient$EndpointEntry$RenewCleanThread.run(DGCClient.java:516)</p>
<p>at java.lang.Thread.run(Thread.java:662)</p>
<p>1）“TIMED_WAITING(on object monitor)”,对于本例而言，是因为本线程调用了java.lang.Object.wait(long timeout)而进入等待状态。</p>
<p>2）“Wait Set”中等待的线程状态就是“in Object.wait()”。 当线程获得了Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，他则调用对象（一般就是被synchronized的对象）的wait()方法，放弃了Monitor，进入Wait Set队列。只有当别的线程在该对象上调用了notify()或者notifyAll(),“Wait Set”队列中线程才得到机会去竞争，但是只有一个线程获得对象的Monitor，恢复到运行态。</p>
<p>3）RMI RenewClean是DGCClient的一部分。DGC指的是Distributed GC,即分布式垃圾回收。</p>
<p>4）请注意，是先locked<0x00000000aa672478>，后waiting on<0x00000000aa672478>，之所以先锁在等同一个对象，分析代码如下：</0x00000000aa672478></0x00000000aa672478></p>
<p>static private class  Lock { };</p>
<p>private Lock lock = new Lock();</p>
<p>public Reference&lt;? extends T&gt;  <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/lang/ref/ReferenceQueue.java" target="_blank" rel="noopener">remove</a>(long timeout)</p>
<p>{</p>
<pre><code>synchronized (lock) {

    Reference&lt;? extends T&gt; r =  [reallyPoll](http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/lang/ref/ReferenceQueue.java#ReferenceQueue.reallyPoll%28%29)();

    if (r != null) return r;

    for (;;) {

         [lock](http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/lang/ref/ReferenceQueue.java#ReferenceQueue.0lock). [wait](http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/lang/Object.java#Object.wait%28long%29)(timeout);

        r =  [reallyPoll](http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/lang/ref/ReferenceQueue.java#ReferenceQueue.reallyPoll%28%29)();

        ……

   }
</code></pre><p>}</p>
<p>即，线程的执行中，先用synchronized获得了这个对象的Monitor(对应于locked<0x00000000aa672478>)；当执行到lock.wait(timeout)，线程就放弃了Monitor的所有权，进入“Wait Set”队列</0x00000000aa672478></p>
<p>5）从堆栈信息看，是正在清理remote references to  remote objects,引用的租约到了，分布式垃圾回收在逐一清理呢。</p>
]]></content>
      
        <categories>
            
            <category> 调优 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 调优 </tag>
            
            <tag> jstack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[分析String源码所得]]></title>
      <url>/2017/11/30/2017-11-30--%E5%88%86%E6%9E%90String%E6%BA%90%E7%A0%81%E6%89%80%E5%BE%97/</url>
      <content type="html"><![CDATA[<p>1.String 中没有对+进行重载，java中没有对运算符重载，String的+的操作是在编译的时候new StringBuilder,在调用append方法来进行+操作的。</p>
<p>2.String 源码分析</p>
<p><code>public boolean equals(Object anObject) {</code></p>
<pre><code>if (this == anObject) {
</code></pre><a id="more"></a>
<pre><code>        return true;

    }

    if (anObject instanceof String) {

        String anotherString = (String) anObject;

        int n = value.length;

        if (n == anotherString.value.length) {

            char v1[] = value;

            char v2[] = anotherString.value;

            int i = 0;

            while (n-- != 0) {

                if (v1[i] != v2[i])

                        return false;

                i++;

            }

            return true;

        }

    }

    return false;

`}`
</code></pre><p>分析：</p>
<p>String 的 equals 包含了 “==“ ，双等号比较的是地址，地址相同，内容肯定相同，当地址不相同的时候，比较的是两个字符串中的每一个字符，完全相同则表示相等，返回true，否则返回false。</p>
]]></content>
      
        <categories>
            
            <category> 源码 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring aop源码分析]]></title>
      <url>/2017/11/30/2017-11-30--spring-aop%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>源码分析：</p>
<p>这里先描述aop的具体流程：</p>
<p>一、解析xml</p>
<p>1.加载xml资源文件时解析<aop:aspectj-autoproxy expose-proxy="true" proxy-target-class="true"></aop:aspectj-autoproxy></p>
<a id="more"></a>
<p>2.在parse函数里面解析这个标签①加载一个bean，这个bean的功能是根据注解来给相应的bean创建代理②处理proxy-target-class属性，当这个属性为true时，创建的代理是CGLIB 代理，处理 expose-proxy这个属性，这个属性为true，允许用户通过上下文的方式实现类内部调用也能增强。</p>
<p>二、加载bean</p>
<p>1.初始化bean的时候，在bean initialize之后会调用postProcessObjectFromFactoryBean方法</p>
<p>2.该方法中调用wrapIfNecessary方法，该方法中有两个重要的步骤①getAdvicesAndAdvisorsForBean获取该bean的所有拦截器，这个方法中分几个步骤：获取beanFactory中所有的bean，遍历找出AspectJ注解的bean,获取bean中所有的拦截器，存到缓存中，然后找到适合当前bean的所有拦截器②创建代理createProxy,这个方法中会根据用户配置比如proxy-target-class，被代理类是否implement接口等等来决定是否用jdk代理还是CGLIB代理，然后创建相应代理。</p>
<p>这里讲解一下jdk代理和CGLIB代理的区别和两者的源码分析：</p>
<p>jdk代理：是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理</p>
<p>CGLIB代理：利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理</p>
<p>1.如果目标对象实现了接口，默认情况下采取jdk的动态代理</p>
<p>2.如果目标对象实现了接口，可以强制采用CGLIB代理</p>
<p>3.如果目标没有实现接口，只能采用CGLIB代理</p>
<p>jdk代理使用方法：</p>
<p><code>public interface Say {</code></p>
<pre><code>void say();
</code></pre><p><code>}</code></p>
<p><code>public class SayImpl implements Say {</code></p>
<pre><code>@Override

public void say() {

    System.out.println(&quot;say hello&quot;);

}
</code></pre><p><code>}</code></p>
<p><code>public class MyInvocationHandler implements InvocationHandler{</code></p>
<pre><code>private Object targetObject;

@Override

public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

    System.out.println(&quot;say before&quot;);

    Object object = method.invoke(targetObject,args);

    System.out.println(&quot;say after&quot;);

    return object;

}

public Object newProxy(Object targetObject){

    this.targetObject=targetObject;

    return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),targetObject.getClass().getInterfaces(),this);

}
</code></pre><p><code>}</code></p>
<p><code>public class TestJDKProxy {</code></p>
<pre><code>public static void main(String[] args){

    MyInvocationHandler myInvocationHandler = new MyInvocationHandler();

    Say say = (Say) myInvocationHandler.newProxy(new SayImpl());

    say.say();

}
</code></pre><p><code>}</code></p>
<p>根据源码分析生成的代理类叫ProxyN，所以在生成代理之后，把这个类写到硬盘，通过以下这个方法：</p>
<p><code>public class Util {</code></p>
<pre><code>public static void writeProxyClassToHardDisk(String path){

    byte[] classFile = ProxyGenerator.generateProxyClass(&quot;$Proxy0&quot;, SayImpl.class.getInterfaces());

    FileOutputStream out = null;

    try{

        out = new FileOutputStream(path);

        out.write(classFile);

        out.flush();

    }catch (Exception e){

        e.printStackTrace();

    }finally {

        try{

            out.close();

        }catch (Exception e){

            e.printStackTrace();

        }

    }

}
</code></pre><p><code>}</code></p>
<p>此时通过反编译生成的class文件，即可得到生成代理类的源码如下：</p>
<p><code>public final class $Proxy0 extends Proxy</code></p>
<p>   implements Say</p>
<p><code>{</code></p>
<p>   private static Method m3;</p>
<p>   private static Method m1;</p>
<p>   private static Method m0;</p>
<p>   private static Method m2;</p>
<p>   public $Proxy0(InvocationHandler invocationhandler)</p>
<p>   {</p>
<pre><code>super(invocationhandler);
</code></pre><p>   }</p>
<p>   public final void say()</p>
<p>   {</p>
<pre><code>try

{

   super.h.invoke(this, m3, null);

   return;

}

catch (Error ) { }

catch (Throwable throwable)

{

   throw new UndeclaredThrowableException(throwable);

}
</code></pre><p>   }</p>
<p>   public final boolean equals(Object obj)</p>
<p>   {</p>
<pre><code>try

{

   return ((Boolean)super.h.invoke(this, m1, new Object[] {

      obj

   })).booleanValue();

}

catch (Error ) { }

catch (Throwable throwable)

{

   throw new UndeclaredThrowableException(throwable);

}
</code></pre><p>   }</p>
<p>   public final int hashCode()</p>
<p>   {</p>
<pre><code>try

{

   return ((Integer)super.h.invoke(this, m0, null)).intValue();

}

catch (Error ) { }

catch (Throwable throwable)

{

   throw new UndeclaredThrowableException(throwable);

}
</code></pre><p>   }</p>
<p>   public final String toString()</p>
<p>   {</p>
<pre><code>try

{

   return (String)super.h.invoke(this, m2, null);

}

catch (Error ) { }

catch (Throwable throwable)

{

   throw new UndeclaredThrowableException(throwable);

}
</code></pre><p>   }</p>
<p>   static </p>
<p>   {</p>
<pre><code>try

{

   m3 = Class.forName(&quot;com.springapp.mvc.Proxy.jdkProxy.Say&quot;).getMethod(&quot;say&quot;, new Class[0]);

   m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] {

      Class.forName(&quot;java.lang.Object&quot;)

   });

   m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);

   m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);

}

catch (NoSuchMethodException nosuchmethodexception)

{

   throw new NoSuchMethodError(nosuchmethodexception.getMessage());

}

catch (ClassNotFoundException classnotfoundexception)

{

   throw new NoClassDefFoundError(classnotfoundexception.getMessage());

}
</code></pre><p>   }</p>
<p><code>}</code></p>
<p>cglib代理的使用方法：</p>
<p><code>public class SayHello {</code></p>
<pre><code>public void say(){

    System.out.println(&quot;hello everyone&quot;);

}
</code></pre><p><code>}</code></p>
<p><code>public class CglibProxy implements MethodInterceptor {</code></p>
<pre><code>private Enhancer enhancer = new Enhancer();

public Object getProxy(Class clazz){

    enhancer.setSuperclass(clazz);

    enhancer.setCallback(this);

    return enhancer.create();

}

@Override

public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {

    System.out.println(&quot;前置代理&quot;);

    Object res = methodProxy.invokeSuper(o,objects);

    System.out.println(&quot;后置处理&quot;);

    return res;

}
</code></pre><p><code>}</code></p>
<p><code>public class DoCglib {</code></p>
<pre><code>public static void main(String[] args){

    CglibProxy proxy = new CglibProxy();

    SayHello proxyImpl = (SayHello)proxy.getProxy(SayHello.class);

    proxyImpl.say();

}
</code></pre><p><code>}</code></p>
<p>spring中jdk代理的处理：</p>
<p>spring中的jdkDynamicAopProxy确实实现了InvocationHandler接口，其中也包含了getProxy和invoke。其中getProxy函数创建了代理，</p>
<p>invoke函数里面包含了AOP的核心逻辑，这个方法逻辑：</p>
<p>1.处理equals方法</p>
<p>2.处理hash方法</p>
<p>3.处理expose属性，当这个属性为true时，暴露代理来实现内部调用是能通过代理实现增强</p>
<p>4.获取当前方法的所有拦截器</p>
<p>5.如果没有拦截器,那么直接调用切点方法，如果有会将拦截器封装到ReflectiveMethodInvocation</p>
<p>6.调用ReflectiveMethodInvocation类中的proceed方法</p>
<p>7.proceed方法中维护了链接调用的计数器，记录当前调用链接的位置，他会根据传入的拦截器链获取要执行的拦截器，然后实例化InterceptorAndDynamicMethodMatcher,InterceptorAndDynamicMethodMatcher中有两个属性MethodInterceptor、MethodMatcher,这两个属性的作用分别是：MethodInterceptor是一个接口，所以他会根据传入不同的拦截器来分发给不同的继承类来实现具体逻辑，比如传入前置拦截器，具体实现则交给了MethodBeforeAdviceInterceptor，在这个类invoke（会传入当前类当参数）方法中会先调用MethodBeforeAdvice的before方法，然后再调用传入类的proceed方法，以此循环，最终执行完拦截器链中的所有拦截器；MethodMatcher是方法匹配器，来检查当前拦截器是否适用当前方法，如果适用则执行拦截器，不适用则略过当前拦截器。</p>
<p>spring中cglib代理的处理：</p>
<p>三、调用方法</p>
<p>jdk代理：由于生成了代理匿名类，所以当调用被代理类的某个方法时，会调用代理类中的invoke方法，具体实现上面已经讲到了。</p>
]]></content>
      
        <categories>
            
            <category> 源码 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ArrayList源码分析]]></title>
      <url>/2017/11/30/2017-11-30--ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>ArrayList的基本存储数据结构为数组</p>
<p><code>ArrayList 的add源码为：</code></p>
<pre><code>public boolean add(E e){

     ensureCapacityInternal(size +1);

     elementData[size++]==e;
</code></pre><a id="more"></a>
<pre><code>     return true;

}
</code></pre><p>``在当前存储结构足够存储的时候，就直接把数组的size+1项的元素设为e即可。</p>
<p>其中的ensureCapacityInternal函数的源码为：</p>
<p><code>private void ensureCapacityInternal(int minCapacity){</code></p>
<pre><code>if(elementData == EMPTY_ELEMENTDATA){

     minCapacity = Math.max(DEFAULT_CAPACITY,minCapacity);

}

ensureExplicitCapacity(minCapacity);
</code></pre><p><code>}</code></p>
<p>``其中DEFULT_CAPACITY为10，即当你初始化ArrayList的时候最小初始大小为10，ensureExplicitCapacity函数的源码为：</p>
<pre><code>`private void ensureExplicitCapacity(int minCapacity){`

     modCount++;

     if(minCapacity - elementData.length&gt;0){

          grow(minCapacity);

     }

}
</code></pre><p>``这里判断了当前需要的size即minCapacity是否大于element的长度，若供小于需，则需要扩容。</p>
<p>grow()的源码为：</p>
<p><code>private void grow(int minCapacity){</code></p>
<pre><code>int oldCapacity = elementData.length;

int newCapacity = oldCapacity+(oldCapacity&gt;&gt;1);

if(newCapacity - minCapacity&lt;0)

     newCapacity=minCapacity;

if(newCapacity-MAX_ARRAY_SIZE&gt;0)

     newCapacity = hugeCapacity(minCapacity);

 elementData = Arrays.copyof(element,newCapacity);
</code></pre><p><code>}</code></p>
<p>这里就是先确定扩容后的ArrayList数组的大小，然后在调用coryof，拷贝到新的数组中后赋给elementData。从这段源码可以知道ArrayList的存储数量是有限的，通过hugeCapacity函数得知为Integer的MAX_VALUE，想想也是，当存储超过Integer的最大值时，数组的下标无法表示的啊。</p>
<p>以上讲完ArrayList的add函数后，我们看看remove的源码：</p>
<p><code>public E remove(int index){</code></p>
<pre><code>rangeCheck(index);

modCount++;

E oldValue=elementData(index);

int numMoved = size -index -1;

if(numMoved&gt;0){

     System.arraycopy(elementData,index+1,elementData,index,numMoved);

}

elementData[--size]=null;

return oldValue;
</code></pre><p> <code>}</code></p>
<p>从以上源码可以得知，当删除元素时是非常耗时的，他会把要删除的元素的后面所有元素都向前复制（移动）一位，然后ArrayList的size-1,之前位置的value置为null,方便GC回收。</p>
<p>我们再看get的源码:</p>
<p><code>public E get(int index){</code></p>
<pre><code>rangeCheck(index);

checkForComodification();

return ArrayList.this.elementData(offset+index);
</code></pre><p><code>}</code></p>
<p>就是检查的下标是否越界，然后拿出来从初始存储位置加上index的元素值。</p>
<p><code>public E set(int index,E e){</code></p>
<pre><code>rangeCheck(index);

checkForComodification();

E oldValue = Array.this.elementData(offset + index);

ArrayList.this.elementData[offset +index]=e;

return oldValue;
</code></pre><p><code>}</code></p>
<p>这段源码比较容易理解，也是先检查了是否数组越界。</p>
<p>contains的源码为：</p>
<p><code>public boolean contains(Object o){</code></p>
<pre><code>return indexOf(o)&gt;=0;
</code></pre><p><code>}</code></p>
<p><code>public int indexOf(Object o){</code></p>
<pre><code>if(o==null){

     for(int i=0;i&lt;size;i++){

          if(elementData[i]==null)

               return i;

     }

}else {

     for(int i=0;i&lt;size;i++){

          if(o.equals(elementData[i))

               return i;

     }

}

return -1;
</code></pre><p><code>}</code></p>
<p>通过以上源码得知，检查是否包含某元素的方式就是遍历所有元素，效率不高。indexOf返回的是第一个等于该值的下标，还有lastIndexOf返回的是最后一个等于该值的下标。</p>
<p>还有clone的源码：</p>
<p><code>public Object clone(){</code></p>
<pre><code>try{

     ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) supper.clone();

     v.elementData = Arrays.copyof(elementData,size);

     v.modCount = 0;

}catch(CloneNotSupportedException e){

     throw new InternalError();

}
</code></pre><p><code>}</code></p>
<p>由此可见ArrayList的clone的克隆只是简单的克隆一下指向，并不会把所有的值再复制一份。</p>
]]></content>
      
        <categories>
            
            <category> 源码 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hashMap源码分析]]></title>
      <url>/2017/11/30/2017-11-30--hashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>java基本存储结构：数组和链表</p>
<p>hashMap就是数组加链表的存储结构。</p>
<p>put源码：</p>
<p><code>public V put(K key, V value) {</code></p>
<pre><code>if (table == EMPTY_TABLE) {
</code></pre><a id="more"></a>
<pre><code>        inflateTable(threshold);

    }

    if (key == null)

        return putForNullKey(value);

    int hash = hash(key);

    int i = indexFor(hash, table.length);

    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {

        Object k;

        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {

            V oldValue = e.value;

            e.value = value;

            e.recordAccess(this);

            return oldValue;

        }

    }

    modCount++;

    addEntry(hash, key, value, i);

    return null;

`}`
</code></pre><p>根据每个key进行hash,hash的源码如下：</p>
<pre><code>`final int hash(Object k) {`

    int h = hashSeed;

    if (0 != h &amp;&amp; k instanceof String) {

        return sun.misc.Hashing.stringHash32((String) k);

    }

    h ^= k.hashCode();

    // This function ensures that hashCodes that differ only by

    // constant multiples at each bit position have a bounded

    // number of collisions (approximately 8 at default load factor).

    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);

    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);

`}`
</code></pre><p>hash的作用就是把每个put进来的值，通过移位与运算，来实现分布均匀，最好的情况就是hashmap数组中每一个位置都有一个值。每次put进去的时候，hashMap的size加1,当size大于容量，通过resize 函数来使hashmap的大小扩容为原来的两倍，内部实现就是再创建一个新的数组，然后通过tranfer来把元素拷贝过去。tranfer的源码如下：</p>
<pre><code>`void transfer(Entry[] newTable, boolean rehash) {`

    int newCapacity = newTable.length;

    for (Entry&lt;K,V&gt; e : table) {

        while(null != e) {

            Entry&lt;K,V&gt; next = e.next;

            if (rehash) {

                e.hash = null == e.key ? 0 : hash(e.key);

            }

            int i = indexFor(e.hash, newCapacity);

            e.next = newTable[i];

            newTable[i] = e;

            e = next;

        }

    }

`}`
</code></pre><p>分析：循环原table,当某个[i]的位置上有两个或以上元素时，循环链表，注意这里是将后循环到的元素插到了链表的头部，另外因为时重新hash值，所以某些元素的位置会发生变化。</p>
<p>以上中的Entry的结构是：</p>
<p><code>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {</code></p>
<pre><code>final K key;

V value;

Entry&lt;K,V&gt; next;

int hash;
</code></pre><p><code>Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {</code></p>
<pre><code>    value = v;

    next = n;

    key = k;

    hash = h;

}
</code></pre><p><code>}</code></p>
]]></content>
      
        <categories>
            
            <category> 源码 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> hashMap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LinkedList源码分析]]></title>
      <url>/2017/11/30/2017-11-30--LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>LinkedList的基本存储结构是链表</p>
<p>LinkedList的节点元素的存储结构为：</p>
<pre><code>`private static class Node&lt;E&gt;{`

     E item;

     Node&lt;E&gt; next;
</code></pre><a id="more"></a>
<pre><code>     Node&lt;E&gt; prev;

     Node(Node&lt;E&gt; prev,E element,Node&lt;E&gt; next){

          this.item = element;

          this.next = next;

          this.prev = prev;

     }

`}`
</code></pre><p>LinkedList的add源码为：</p>
<p><code>public boolean add(E e){</code></p>
<pre><code>linkLast(e);

return true;
</code></pre><p><code>}</code></p>
<p><code>void linkLast(E e){</code></p>
<pre><code>final Node&lt;E&gt; l = last;

final Node&lt;E&gt; newNode = new Node&lt;&gt;(l,e,null);

last = newNode;

if(l==null)

     first = newNode;

else

     l.next = newNode;

size++;

modCount++;
</code></pre><p><code>}</code></p>
<p>因为LinkedList的基本结构是链表，所以add就是在链表的末尾添加一个节点，然后size++，当last==null代表改list为空的，所以头结点置为newNode</p>
<p>linkedList的remove源码为：</p>
<p><code>public boolean remove(Object o){</code></p>
<pre><code>if(o==null){

     for(Node&lt;E&gt; x=first;x!=null;x=x.next){

          if(x.item == null){

               unlink(x);

               return true;

          }

     }

}else{

     for(Node&lt;E&gt; x=first;x!=null;x=x.next){

          if(o.equals(x.item)){

               unlink(x);

               return true;

          }

     }

}

return false;
</code></pre><p><code>}</code></p>
<p>linkedList的remove就是从头遍历节点，然后调用unlink来remove节点，unlink的源码如下：</p>
<p>   <code>E unlink(Node&lt;E&gt; x){</code></p>
<pre><code>     final E element = x.item;

     final Node&lt;E&gt; next = x.next;

     final Node&lt;E&gt; prev = x.prev;

     if(prev == null){

          first=next;

     }else{

          prev.next = next;

          x.prev = null;

     }

     if(next == null){

          last=prev;

     }else{

          next.prev=prev;

          x.next = null;

     }

     x.item = null;

     size--;

     modCount++;

     return element;

}
</code></pre><p>``unlink就是把元素的前节点的next指向该元素的next,把元素的后节点的prev指向该元素的prev,然后把该元素的prev和next和item置为null,方便GC回收。</p>
<p>linkedList的get的源码为：</p>
<p><code>public E get(int index){</code></p>
<pre><code>checkElementIndex(index);

return node(index).item;
</code></pre><p><code>}</code></p>
<p>get的时候先检测了index是否&lt;0或者大于size,若是则抛出异常。node()的源码为：</p>
<p>N<code>ode&lt;E&gt; node(int index){</code></p>
<pre><code>if(index&lt;(size&gt;&gt;1)){

     Node&lt;E&gt; x = first;

     for(int i=0;i&lt;index;i++)

          x=x.next;

     return x;

}else{

     Node&lt;E&gt; x = last;

     for(int i=size-1;i&gt;index;i--)

          x = x.prev;

     return x;

}
</code></pre><p><code>}</code></p>
<p>node方法就是先判断一下index接近first还是last，然后决定从哪个方向开始查找。</p>
<p>linkedList的contains的源码为：</p>
<p><code>public boolean contains(Object o){</code></p>
<pre><code>return indexOf(o)!=-1;
</code></pre><p><code>}</code></p>
<p><code>public int indexOf(Object o){</code></p>
<pre><code>int index = 0;

if(o==null){

     for(Node&lt;E&gt; x=first;x!=null;x=x.next){

          if(x.item == null)

               return index;

          index++;

     }

}else{

     for(Node&lt;E&gt; x = first;x!=null;x=x.next){

             if(o.equals(x.item))

                    return index;

               index++;

     }

}

return -1;
</code></pre><p><code>}</code></p>
<p>contains就是从first开始遍历，查到就返回index</p>
<p>linkedList的clone的源码为：</p>
<p><code>public Object clone(){</code></p>
<pre><code>LinkedList&lt;E&gt; clone = superClone();

clone.first = clone.last=null;

clone.size=0;

clone.modCount = 0;

for(Node&lt;E&gt; x=first;x!=null;x=x.next)

     clone.add(x.item);

return clone;
</code></pre><p><code>}</code></p>
<p>``LinkedList的clone是浅克隆，只是克隆了引用。</p>
]]></content>
      
        <categories>
            
            <category> 源码 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[破解x-pack]]></title>
      <url>/2017/11/28/%E7%A0%B4%E8%A7%A3x-pack/</url>
      <content type="html"><![CDATA[<h1 id="x-pack-安装步骤如下"><a href="#x-pack-安装步骤如下" class="headerlink" title="x-pack 安装步骤如下:"></a>x-pack 安装步骤如下:</h1><h3 id="1-在ES5-0安装-X-PACK"><a href="#1-在ES5-0安装-X-PACK" class="headerlink" title="1.在ES5.0安装 X-PACK"></a>1.在ES5.0安装 X-PACK</h3><p>bin/elasticsearch-plugin install x-pack</p>
<p>如果不需要该插件，也可以通过非常简单的方式删除：</p>
<p>bin/elasticsearch-plugin remove x-pack</p>
<a id="more"></a>
<h3 id="2-在kibana5-0中安装X-PACK"><a href="#2-在kibana5-0中安装X-PACK" class="headerlink" title="2.在kibana5.0中安装X-PACK"></a>2.在kibana5.0中安装X-PACK</h3><p>bin/kibana-plugin install x-pack</p>
<p>卸载：bin/kibana-plugin remove x-pack</p>
<p>安装成功后重启ElasticSearch和Kibana：</p>
<p>以上安装之后，就会发现ES的访问和Kibana的访问都受到限制</p>
<p>默认的用户名和密码：</p>
<p>用户名：elastic</p>
<p>密码：changeme</p>
<p>登录到Kibana会发现 elastic是一个最高级别的user，拥有所有权限，其角色是superuser。</p>
<p>elasticsearch和kibana默认是受限可一修改配置文件来取消限制。具体参见 ：<a href="https://www.elastic.co/guide/en/x-pack/current/installing-xpack.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/x-pack/current/installing-xpack.html</a></p>
<p>登录时不让输入用户和密码，提示license不允许，免费的license只有一年时间，找了一下,可以破解，步骤如下：</p>
<h5 id="1-破解并安装"><a href="#1-破解并安装" class="headerlink" title="1: 破解并安装"></a>1: 破解并安装</h5><p>下载x-pack-5.2.0.zip，</p>
<p>解压并找到x-pack-5.2.0.jar。这里使用JD-GUI是无法反编译的，</p>
<p>我使用的是Luyten(下载地址：<a href="https://github.com/deathmarine/Luyten/releases/tag/v0.5.0）进行反编译。" target="_blank" rel="noopener">https://github.com/deathmarine/Luyten/releases/tag/v0.5.0）进行反编译。</a></p>
<p>将org.elasticsearch/license/LicenseVerifier.class反编译并保存出来。这个类是检查license完整性的类，我们使其始终返回true，就可以任意修改license并导入。将其改为：</p>
<p>package org.elasticsearch.license;</p>
<p><code>import java.nio.*;</code></p>
<p><code>import java.util.*;</code></p>
<p><code>import java.security.*;</code></p>
<p><code>import org.elasticsearch.common.xcontent.*;</code></p>
<p><code>import org.apache.lucene.util.*;</code></p>
<p><code>import org.elasticsearch.common.io.*;</code></p>
<p><code>import java.io.*;</code></p>
<p><code>public class LicenseVerifier</code></p>
<p><code>{</code></p>
<p><code>public static boolean verifyLicense(final License license, final byte[] encryptedPublicKeyData) {</code></p>
<p><code>return true;</code></p>
<p><code>}</code></p>
<p><code>public static boolean verifyLicense(final License license) {</code></p>
<p><code>return true;</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p>注：红色的部分可以都不要</p>
<p>然后需要重新编译class文件。注意这里我们无需编译整个工程，将原来的x-pack-5.2.0.jar和依赖包加入CLASSPATH，即可完成单个文件的编译。实际上只用到了3个依赖包，如果是用RPM或DEB安装的，直接运行：</p>
<p>javac -cp “e:/tools/linux/elasticsearch/5.0/elasticsearch-5.0.0.jar;e:/tools/linux/elasticsearch/5.0/lucene-core-6.2.0.jar;E:/tools/linux/elasticsearch/5.0/x-pack-5.0.0/elasticsearch/x-pack-5.0.0.jar” LicenseVerifier.java</p>
<p>注：javac执行时的参数cp 表示classpath 路径，如果多个在windows环境中用 ; 隔开，linux中用 : 隔开；</p>
<p>把x-pack-5.2.0.jar用压缩文件管理器打开，将里面的LicenseVerifier.class替换掉。再把破解了的jar包部署到各节点上，</p>
<p>将破解的.zip文件安装到服务器,启动 elasticsearch,kibana，并重启集群。安装新的之前要现将已经安装的删除。</p>
<p>./bin/elasticsearch-plugin remove x-pack</p>
<p>./bin/elasticsearch-plugin install file:///srv/x-pack-5.4.1.zip</p>
<p>./bin/kibana-plugin install file:///srv/x-pack-5.4.1.zip</p>
<p>申请一个免费license(<a href="https://license.elastic.co/registration" target="_blank" rel="noopener">https://license.elastic.co/registration</a>) 注册后可以下载文件,下载后修改，例如：</p>
<p>主要修改：type改为platinum表示可以使用所有功能 ; expiry_date_in<em>millis  我这里改了10年 ^</em>^</p>
<p><code>{&quot;license&quot;:{&quot;uid&quot;:&quot;10cf8263-4d23-4e81-b10b-95abfb14b599&quot;,&quot;type&quot;:&quot;platinum&quot;,&quot;issue_date_in_millis&quot;:1490832000000,&quot;expiry_date_in_millis&quot;:1806237751991,&quot;max_nodes&quot;:100,&quot;issued_to&quot;:&quot;www bbb (baiye)&quot;,&quot;issuer&quot;:&quot;Web Form&quot;,&quot;signature&quot;:&quot;+2yc0QcB&quot;,&quot;start_date_in_millis&quot;:1490832000000}}</code></p>
<p>``【安装license】</p>
<p>查看当前的license</p>
<p><code>[root@localhost Downloads]# curl -XGET -u elastic:changeme &#39;http://192.168.100.50:9200/_license&#39;</code></p>
<p>将编辑好的license.json文件放到服务器，在文件目录下执行：</p>
<p><code>[root@localhost Downloads]#curl -XPUT -u elastic:changeme &#39;http://192.168.100.50:9200/_xpack/license&#39; -d @license.json</code></p>
<p>或者下面：</p>
<p><code>[root@localhost Downloads]#curl -XPUT -u elastic:changeme &#39;http://192.168.100.50:9200/_xpack/license?acknowledge=true&#39; -d @license.json</code></p>
<p>重启elasticsearch和kibana .</p>
<p>打开：<a href="http://*.*.***.**:5601/login" target="_blank" rel="noopener">http://*.*.***.**:5601/login</a>  可正常登录。</p>
]]></content>
      
        <categories>
            
            <category> ELK </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ELK </tag>
            
            <tag> 数据 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
